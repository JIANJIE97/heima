1、文件流
java.io.File
java.io.FilterFile接口
2、IO流:
	1、顶级字节流：
		1、输入流：java.io.InputStream
			1、文件输入流:java.io.FileInputStream
			2、反序列化流:java.io.ObjectInputStream
			3、过滤输入流：java.io.FilterInputStream
				1、缓冲输入流:java.io.BufferedInputStream
		2、输出流：java.io.OutputStream
			1、文件输出流:java.io.FileOutputStream
			2、序列化流:java.io.ObjectOutputStream
			3、过滤输出流：java.io.FilterOutputStream
				1、缓冲输出流:java.io.BufferedOutputStream
				2、打印流:java.io.PrintStream
			
	2、顶级字符流：
		1、输入流：java.io.Reader
			1、缓冲输入流:java.io.BufferedReader
			2、转换输入流:java.io.InputStreamReader
				1、文件输入流:java.io.FileReader
			3、过滤输入流：java.io.FilterReader
		2、输入流：java.io.Writer
			1、缓冲输出流:java.io.BufferedWriter
			2、转换输出流:java.io.OutputStreamWriter
				1、文件输出流:java.io.FileWriter
			3、过滤输出流：java.io.FilterWriter
				

			


	





01 File类
	1、File类的概述
		1、java.io.File类:文件和目录路径名的抽象表示形式。
		2、java把电脑中的文件和文件夹(目录)封装为了一个File类,我们可以使用File类对文件和文件夹进行操作
		3、我们可以使用File类的方法
			1、创建一个文件/文件夹
			2、删除文件/文件夹
			
			3、获取文件/文件夹
			4、获取文件的大小
			
			5、判断文件/文件夹是否存在
			6、对文件夹进行遍历
		4、File类是一个与系统无关的类,任何的操作系统都可以使用这个类中的方法
		5、重点:记住这三个单词
			1、file:文件
			2、directory:文件夹/目录
			3、path:路径
	2、File类的静态成员变量
		1、四个静态的成员变量：
			1、static String pathSeparator 与系统有关的路径分隔符，为了方便，它被表示为一个字符串。
				//路径分隔符 windows:分号;  linux:冒号:
            2、static char pathSeparatorChar 与系统有关的路径分隔符。
				注意：File.pathSeparatorChar + "" = File.pathSeparator

            3、static String separator 与系统有关的默认名称分隔符，为了方便，它被表示为一个字符串。
				// 文件名称分隔符 windows:反斜杠\  linux:正斜杠/
            4、static char separatorChar 与系统有关的默认名称分隔符。
				注意：File.separatorChar + "" = File.separator
				
		2、注意事项：
			1、以后的操作路径:路径不能写死了
				1、C:\develop\a\a.txt  windows
				2、C:/develop/a/a.txt  linux
            兼容写法："C:"+File.separator+"develop"+File.separator+"a"+File.separator+"a.txt"
	3、绝对路径和相对路径
		1、路径:
			1、绝对路径:是一个完整的路径
				以盘符(c:,D:)开始的路径
					c:\\a.txt
					C:\\Users\itcast\\IdeaProjects\\shungyuan\\123.txt
					D:\\demo\\b.txt
			2、相对路径:是一个简化的路径
				相对指的是相对于当前项目的根目录(C:\\Users\itcast\\IdeaProjects\\shungyuan)
				如果使用当前项目的根目录,路径可以简化书写
				C:\\Users\itcast\\IdeaProjects\\shungyuan\\123.txt-->简化为: 123.txt(可以省略项目的根目录)
        2、注意:
            1.路径是不区分大小写
            2.路径中的文件名称分隔符windows使用反斜杠,反斜杠是转义字符,两个反斜杠代表一个普通的反斜杠
	4、File类的构造方法
		1、File(String pathname) 通过将给定路径名字符串转换为抽象路径名来创建一个新 File 实例。
			参数:
				1、String pathname:字符串的路径名称
				2、路径可以是以文件结尾,也可以是以文件夹结尾
				3、路径可以是相对路径,也可以是绝对路径
				4、路径可以是存在,也可以是不存在，因为创建File对象,只是把字符串路径封装为File对象,不考虑路径的真假情况
		2、File(String parent, String child) 根据 parent 路径名字符串和 child 路径名字符串创建一个新 File 实例。
			参数:把路径分成了两部分
				String parent:父路径
				String child:子路径
			好处:
				父路径和子路径,可以单独书写,使用起来非常灵活;父路径和子路径都可以变化
				
		3、File(File parent, String child) 根据 parent 抽象路径名和 child 路径名字符串创建一个新 File 实例。
			参数:把路径分成了两部分
				File parent:父路径
				String child:子路径
			好处:
				 父路径和子路径,可以单独书写,使用起来非常灵活;父路径和子路径都可以变化
				 父路径是File类型,可以使用File的方法对路径进行一些操作,再使用路径创建对象
	5、File类获取功能的方法
        1、public String getAbsolutePath() ：返回此File的绝对路径名字符串。
			 获取的构造方法中传递的路径,无论路径是绝对的还是相对的,getAbsolutePath方法返回的都是绝对路径
        2、public String getPath() ：将此File转换为路径名字符串。
			1、获取的构造方法中传递的路径。构造方法写的是相对路径就返回相对路径，写的是绝对路径返回的也是绝对路径。
			2、toString方法调用的就是getPath方法
				源码:
					public String toString() {
						return getPath();
					}
        3、public String getName()  ：返回由此File表示的文件或目录的名称。
			获取的就是构造方法传递路径的结尾部分(文件/文件夹)
        4、public long length()  ：返回由此File表示的文件的长度。
			获取的是构造方法指定的文件的大小,以字节为单位。
			注意:
				1、文件夹是没有大小概念的,如果获取文件夹的大小，那会返回0
				2、如果构造方法中给出的路径不存在,那么length方法返回0
	6、File类判断功能的方法
        1、public boolean exists() ：此File表示的文件或目录是否实际存在。
			用于判断构造方法中的路径是否存在
				存在:true
				不存在:false
        2、public boolean isDirectory() ：此File表示的是否为目录。
			用于判断构造方法中给定的路径是否以文件夹结尾
                是:true
                否:false
        3、public boolean isFile() ：此File表示的是否为文件。
			用于判断构造方法中给定的路径是否以文件结尾
                是:true
                否:false
				
		注意:
            电脑的硬盘中只有文件/文件夹,两个方法是互斥
            这两个方法使用前提,路径必须是存在的,否则都返回false。所以使用isDirectory()和isFile()之前使用exists()
	7、File类创建删除功能的方法
		1、public boolean createNewFile() ：当且仅当具有该名称的文件尚不存在时，创建一个新的空文件。
			1、创建文件的路径和名称在构造方法中给出(构造方法的参数)
			2、返回值:布尔值
				1、true:文件不存在,创建文件,返回true
				2、false:文件存在,不会创建,返回false
			3、注意:
				1.此方法只能创建文件,不能创建文件夹,虽然创建出来的文件没有后缀名
				2.创建文件的路径必须存在,否则会抛出异常(IOException: 系统找不到指定的路径。)
			4、public boolean createNewFile() throws IOException
				createNewFile声明抛出了IOException,我们调用这个方法,就必须的处理这个异常,要么throws,要么trycatch
		
        2、public boolean delete() ：删除由此File表示的文件或目录。
			1、此方法,可以删除构造方法路径中给出的文件/文件夹
			2、返回值:布尔值
				1、true:文件/文件夹删除成功,返回true
				2、false:
					1、文件夹中有内容,不会删除返回false;
					2、构造方法中路径不存在false;
			3、注意:
				delete方法是直接在硬盘删除文件/文件夹,不走回收站,删除要谨慎
		
		
        3、public boolean mkdir() ：创建由此File表示的目录。
			创建单级空文件夹
			
			返回值:布尔值
            true:文件夹不存在,创建文件夹,返回true
            false:
				1、文件夹存在,不会创建,返回false;(文件存在也会返回false)
				2、构造方法中给出的路径不存在返回false;
			注意:
				1.此方法只能创建文件夹,不能创建文件
				2、如果该目录下存在同名的文件，那么就不能创建同名的文件夹(例如存在aaa的文件，那么创建aaa文件夹时会返回false)
					即该目录下文件夹与文件的名称不能相同。否则会冲突。
        4、public boolean mkdirs() ：创建由此File表示的目录，包括任何必需但不存在的父目录。
			既可以创建单级空文件夹,也可以创建多级文件夹
			
			返回值:布尔值
            true:
				1、文件夹不存在,创建文件夹,返回true;
				2、构造方法中给出的路径不存在不会返回false,而是返回true并且会根据这个路径创建出新的文件夹;
            false:
				1、文件夹存在,不会创建,返回false;(文件存在也会返回false)
			注意:
				1.此方法只能创建文件夹,不能创建文件
				2、如果该目录下存在同名的文件，那么就不能创建同名的文件夹(例如存在aaa的文件，那么创建aaa文件夹时会返回false)
					即该目录下文件夹与文件的名称不能相同。否则会冲突。
			
	8、File类遍历(文件夹)目录功能
        1、public String[] list() ：返回一个String数组，表示该File目录中的所有子文件或目录。
        2、public File[] listFiles() ：返回一个File数组，表示该File目录中的所有的子文件或目录。

		注意:
			1、list方法和listFiles方法遍历的是构造方法中给出的目录
			2、如果构造方法中给出的目录的路径不存在,会抛出空指针异常
			3、如果构造方法中给出的路径不是一个目录,也会抛出空指针异常
			4、会把隐藏文件和隐藏文件夹也会显示出来
02 递归
	1、递归概念&分类&注意事项
		1、递归:方法自己调用自己
		2、递归的分类:
			1、递归分为两种，直接递归和间接递归。
			2、直接递归称为方法自身调用自己。
			3、间接递归可以A方法调用B方法，B方法调用C方法，C方法调用A方法。
		3、注意事项：
			1、递归一定要有条件限定，保证递归能够停止下来，否则会发生栈内存溢出。(Exception in thread "main" java.lang.StackOverflowError)
			2、在递归中虽然有限定条件，但是递归次数不能太多。否则也会发生栈内存溢出。(Exception in thread "main" java.lang.StackOverflowError)
				注意：
					递归导致栈内存溢出的原理：当一个方法调用其他方法的时候，被调用的方法没有执行完毕，
					当前方法会一直等待被调用的方法执行完毕，才会继续执行
			3、构造方法,禁止递归(编译报错:构造方法是创建对象使用的,一直递归会导致内存中有无数多个对象,直接编译报错)
		4、递归的使用前提:
			当调用方法的时候,方法的主体不变,每次调用方法的参数不同,可以使用递归
	2、练习_使用递归计算1-n之间的和
		1、递归求和的原理：使用递归求和，main方法会调用sum()方法，sum会一直调用sum()方法。
			导致在内存中存在多个sum方法(频繁的创建方法、调用方法、销毁方法)，效率低下
			故：如果仅仅是计算1-n之间的和。不推荐使用递归，使用for循环即可
		2、题目分析：
			1、定义一个方法,使用递归计算1-n之间的和
				1+2+3+...+n
				n+(n-1)+(n-2)+...+1
			2、已知:
				最大值:n
				最小值:1
			3、使用递归必须明确:
				1.递归的结束条件
					获取到1的时候结束
				2.递归的目的(确定递归的返回值和形参)
					获取下一个被加的数字(n-1)

	3、练习_使用递归计算阶乘
	4、练习_递归打印多级目录

		1、需求:
			遍历c:\\abc文件夹,及abc文件夹的子文件夹
			c:\\abc
			c:\\abc\\abc.txt
			c:\\abc\\abc.java
			c:\\abc\\a
			c:\\abc\\a\\a.jpg
			c:\\abc\\a\\a.java
			c:\\abc\\b
			c:\\abc\\b\\b.java
			c:\\abc\\b\\b.txt
			
		2、代码案例：
			public static void main(String[] args) {
				File file = new File("c:\\abc");
				getAllFiles(file);
			}

			private static void getAllFiles(File file) {
				System.out.println(file);
				File[] files = file.listFiles();
				for (File f : files) {
					if(f.isDirectory()){
						getAllFiles(f);
					}else{
						System.out.println(f);
					}
				}
			}
	5、综合案例_文件搜索
		1、需求:
			遍历c:\\abc文件夹,及abc文件夹的子文件夹
			只要.java结尾的文件
		2、代码案例：
			public static void main(String[] args) {
				File file = new File("c:\\abc");
				getAllFiles(file);
			}

			private static void getAllFiles(File file) {
				//System.out.println(file);
				File[] files = file.listFiles();
				for (File f : files) {
					if(f.isDirectory()){
						getAllFiles(f);
					}else{
						if(f.getName().toLowerCase().endsWith(".java")){
							System.out.println(f);
						}
					}
				}
			}
		3、注意事项：
				String类有一个endsWith(".java")方法：返回的该字符串是不是以.java结尾。返回值时布尔值
		
03 过滤器
	1、FileFilter过滤器的原理和使用
		1、需求:
			遍历c:\\abc文件夹,及abc文件夹的子文件夹
			只要.java结尾的文件
			c:\\abc
			c:\\abc\\abc.txt
			c:\\abc\\abc.java
			c:\\abc\\a
			c:\\abc\\a\\a.jpg
			c:\\abc\\a\\a.java
			c:\\abc\\b
			c:\\abc\\b\\b.java
			c:\\abc\\b\\b.txt
		2、我们可以使用过滤器来实现
			1、在File类中有两个和ListFiles重载的方法,方法的参数传递的就是过滤器
				1、File[] listFiles(FileFilter filter)
					1、java.io.FileFilter接口:用于抽象路径名(File对象)的过滤器。
					2、作用:用来过滤文件(File对象)
					3、抽象方法:用来过滤文件的方法
						boolean accept(File pathname) 测试指定抽象路径名是否应该包含在某个路径名列表中。
						参数:
							File pathname:使用ListFiles方法遍历目录,得到的每一个文件对象
				2、File[] listFiles(FilenameFilter filter)
					1、java.io.FilenameFilter接口:实现此接口的类实例可用于过滤器文件名。
					2、作用:用于过滤文件名称
					3、抽象方法:用来过滤文件的方法
						boolean accept(File dir, String name) 测试指定文件是否应该包含在某一文件列表中。
						参数:
							File dir:构造方法中传递的被遍历的目录
							String name:使用ListFiles方法遍历目录,获取的每一个文件/文件夹的名称
		3、注意:
			两个过滤器接口是没有实现类的,需要我们自己写实现类,重写过滤的方法accept,在方法中自己定义过滤的规则
			
			
		4、FileFilter过滤器的原理：
			1、过滤器中的accept()方法是谁调用的(被listFiles()方法调用)
				1、过滤器使用时机：在遍历目录的所有文件或者文件夹时使用(重载了listFiles()方法，参数就是FileFilter过滤器接口)
				2、含有过滤器接口的listFiles()方法被调用时一共做了3件事
					1、listFiles()方法会对构造方法中传递的目录进行遍历，获取目录中的每一个文件/文件夹，封装成为File对象
					2、listFiles()方法会调用参数传递的过滤器接口中的抽象方法accept()
					3、listFiles()方法会把遍历得到的每一个File对象，传递给FileFilter过滤器接口的抽象方法accept()中的参数pathname
			2、accept()方法的参数pathname是什么(获取目标目录中的每一个文件/文件夹，得到的每一个File对象)
				1、accept()方法返回值是一个布尔值
					1、listFiles()方法调用accept()方法获取到布尔值，如果：
						true:就会把传递过去的File对象保存到File数组中
						false:就不会把传递过去的File对象保存到File数组中
						
					2、listFiles()方法返回的是经过FileFilter过滤器接口过滤后的File对象数组
			3、过滤的规则：
				在accept()方法中,判断File对象是否是以".java"结尾。是就返回true。不是返回false
				注意：如果是文件夹直接返回true。(因为文件夹里面可能存在符合条件的文件，直接返回true。让它进入文件夹判断。存在递归)
	2、FileNameFilter过滤器的使用和Lambda优化程序
		1、//使用FilenameFilter过滤器接口
			File[] files = file.listFiles((File d,String name)->{
				return new File(d,name).isDirectory() || name.toLowerCase().endsWith(".java");
			});
		2、//优化Lambda表达式
			File[] files = file.listFiles((d,name)-> new File(d,name).isDirectory() || name.toLowerCase().endsWith(".java"));
		3、注意：FileFilter接口中的accept()方法的参数File dir是扫描目录的父目录对象(即不包含最后的文件名或者文件夹名),name是最后的文件名称
		
		
		
		
		
		
		教学目标
			1、能够说出IO流的分类和功能
			2、能够使用字节输出流写出数据到文件
			3、能够使用字节输入流读取数据到程序
			4、能够理解读取数据read(byte[])方法的原理
			5、能够使用字节流完成文件的复制
			6、能够使用FileWirter写数据到文件
			7、能够说出FileWriter中关闭和刷新方法的区别
			8、能够使用FileWriter写数据的5个方法
			9、 能够使用FileWriter写数据实现换行和追加写
			10、能够使用FileReader读数据
			11、能够使用FileReader读数据一次一个字符数组
			12、能够使用Properties的load方法加载文件中配置信息
			
		主要内容
			1、IO流
			2、字节流
			3、字符流
			4、异常处理
			5、Properties


04 IO字节流
	1、IO概述(概念&分类)
		1、内存(临时存储)------>硬盘(永久存储)
			输出：把内存中的数据，写出到硬盘中
			输入：把硬盘中的数据，读取到内存中
			
		2、io流:
			i：input输入(读取)
			o：output输出(写出)
			流：数据(字符、字节)
				1个字符 = 2个字节;
				1个字节 = 8个二进制位
				
		3、顶级父类：		
		 				输入流			输出流
			字节流：InputStream			OutputStream
			字符流：Reader				Writer
	2、一切皆为字节
		一切文件数据(文本、图片、视频等)在存储时，都是以二进制数字的形式保存，都一个一个的字节，那么传输时一样如此。
		所以，字节流可以传输任意文件数据。在操作流的时候，我们要时刻明确，无论使用什么样的流对象，底层传输的始终为二进制数据。
	3、字节输出流_OutputStream类&FileOutputStream类介绍
		1、java.io.OutputStream:字节输出流
			此抽象类是表示输出字节流的所有类的超类。

		2、定义了一些子类共性的成员方法:
			1、public void close() ：关闭此输出流并释放与此流相关联的任何系统资源。
			2、public void flush() ：刷新此输出流并强制任何缓冲的输出字节被写出。
			3、public void write(byte[] b)：将 b.length字节从指定的字节数组写入此输出流。
			4、public void write(byte[] b, int off, int len) ：从指定的字节数组写入 len字节，从偏移量 off开始输出到此输出流。
			5、public abstract void write(int b) ：将指定的字节输出流。

		3、java.io.FileOutputStream extends OutputStream
			1、FileOutputStream:文件字节输出流
			2、作用:把内存中的数据写入到硬盘的文件中
			3、构造方法:
				1、FileOutputStream(String name)创建一个向具有指定名称的文件中写入数据的输出文件流。
				2、FileOutputStream(File file) 创建一个向指定 File 对象表示的文件中写入数据的文件输出流。
				3、参数:写入数据的目的
					1、String name:目的地是一个文件的路径
					2、File file:目的地是一个文件
				4、构造方法的作用:
					1.创建一个FileOutputStream对象
					2.会根据构造方法中传递的文件/文件路径,创建一个空的文件
					3.会把FileOutputStream对象指向创建好的文件
	4、字节输出流写入数据到文件
		1、写入数据的原理(内存-->硬盘)
			java程序-->JVM(java虚拟机)-->OS(操作系统)-->OS调用写数据的方法-->把数据写入到文件中

		2、字节输出流的使用步骤(重点):
			1.创建一个FileOutputStream对象,构造方法中传递写入数据的目的地
			2.调用FileOutputStream对象中的方法write,把数据写入到文件中
			3.释放资源(流使用会占用一定的内存,使用完毕要把内存清空,提供程序的效率)
	5、文件存储的原理和记事本打开文件的原理
		1、文件存储的原理
			1、FileOutputStream类的构造方法创建了一个文件,并指向了该文件
			2、FileOutputStream流对象写数据的时候，会把十进制的数字转换为二进制。再写出到流对象对应的文件中
		2、记事本打开文件的原理
			1、任意的文本编辑器(记事本、Notepadd++)在打开文件的时候。都会先查询编码表，把字节转换为字符表示
			2、转换规则：
				0-127：查询ASCII表
				其他值：查询系统默认编码表(中文系统GBK)
	6、字节输出流写多个字节的方法
		1、一次写多个字节的方法:
			1、public void write(byte[] b)：将 b.length字节从指定的字节数组写入此输出流。
			2、public void write(byte[] b, int off, int len) ：从指定的字节数组写入 len字节，从偏移量 off开始输出到此输出流。
		2、注意事项：
			1、如果写的第一个字节是正数(0-127),那么显示的时候会查询ASCII表
            2、如果写的第一个字节是负数,那第一个字节会和第二个字节,两个字节组成一个中文显示,查询系统默认码表(GBK)
			3、写入字符的方法:可以使用String类中的方法把字符串,转换为字节数组。String类的成员方法：byte[] getBytes()  把字符串转换为字节数组
				注意：在编写时字符串的时候如果你是在UTF-8的模式下输入字符串那么字节数组是3个代表一个中文。如果是在GBK的模式下输入，则代表2个代表一个中文
	7、字节输出流的续写和换行
		1、追加写/续写:使用两个参数的构造方法
			1、FileOutputStream(String name, boolean append)创建一个向具有指定 name 的文件中写入数据的输出文件流。
			2、FileOutputStream(File file, boolean append) 创建一个向指定 File 对象表示的文件中写入数据的文件输出流。
			3、参数:
			   1、String name,File file:写入数据的目的地
			   2、boolean append:追加写开关
					true:创建对象不会覆盖源文件,继续在文件的末尾追加写数据
					false:创建一个新文件,覆盖源文件
		2、写换行:写换行符号
			1、windows:\r\n
			2、linux:/n
			3、mac:/r
	8、字节输入流_InputStream类&FileInputStream类介绍
		1、java.io.InputStream:字节输入流
			此抽象类是表示字节输入流的所有类的超类。

		2、定义了所有子类共性的方法:
			1、int read()从输入流中读取数据的下一个字节。
			2、int read(byte[] b) 从输入流中读取一定数量的字节，并将其存储在缓冲区数组 b 中。
			3、void close() 关闭此输入流并释放与该流关联的所有系统资源。

		3、java.io.FileInputStream extends InputStream
			1、FileInputStream:文件字节输入流
			2、作用:把硬盘文件中的数据,读取到内存中使用
			3、构造方法:
				1、FileInputStream(String name)
				2、FileInputStream(File file)
				3、参数:读取文件的数据源
					1、String name:文件的路径
					2、File file:文件
				4、构造方法的作用:
					1.会创建一个FileInputStream对象
					2.会把FileInputStream对象指定构造方法中要读取的文件
	9、字节输入流读取字节数据
		1、读取数据的原理(硬盘-->内存)
			java程序-->JVM-->OS-->OS读取数据的方法-->读取文件

		2、字节输入流的使用步骤(重点):
			1.创建FileInputStream对象,构造方法中绑定要读取的数据源
				FileInputStream fis = new FileInputStream("09_IOAndProperties\\c.txt");
			2.使用FileInputStream对象中的方法read,读取文件
				1、int read()读取文件中的一个字节并返回,读取到文件的末尾返回-1
				2、发现以上读取文件是一个重复的过程,所以可以使用循环优化。不知道文件中有多少字节,使用while循环。while循环结束条件,读取到-1的时候结束
				3、布尔表达式(len = fis.read())!=-1
					1.fis.read():读取一个字节
					2.len = fis.read():把读取到的字节赋值给变量len
					3.(len = fis.read())!=-1:判断变量len是否不等于-1
			3.释放资源
				fis.close();
				
				
				
		3、代码案例：
			//1.创建FileInputStream对象,构造方法中绑定要读取的数据源
			FileInputStream fis = new FileInputStream("09_IOAndProperties\\c.txt");
			//2.使用FileInputStream对象中的方法read,读取文件（注意：使用read()方法读取一个字节后指针自动向后移动一位）
			int len = 0; //记录读取到的字节
			while((len = fis.read())!=-1){
				System.out.print(len);//abc
			}
			//3.释放资源
			fis.close();
	10、字节输入流一次读取一个字节的原理
		1、FileInputStream类的构造方法使FileInputStream流对象指向硬盘中的文件
		2、流对象的成员方法read()，调用JVM，然后在调用os操作系统。os调用读取文件的方法，最后读取文件中一个字节返回
		3、不同的操作系统中文件的结束标记不一样。返回结束标记时。返回到JVM虚拟机的时候。虚拟机把结束标记转换为了-1
	11、字节输入流一次读取多个字节
		1、字节输入流一次读取多个字节的方法:
			int read(byte[] b) 从输入流中读取一定数量的字节，并将其存储在缓冲区数组 b 中。
		2、明确两件事情:
			1.方法的参数byte[]的作用?
				起到缓冲作用,存储每次读取到的多个字节
				数组的长度一把定义为1024(1kb)或者1024的整数倍
			2.方法的返回值int是什么?
				每次读取的有效字节个数

		3、String类的构造方法
			String(byte[] bytes) :把字节数组转换为字符串
			String(byte[] bytes, int offset, int length) 把字节数组的一部分转换为字符串 offset:数组的开始索引 length:转换的字节个数
			
			
		4、案例代码：
			//1、创建FileInputStream对象,构造方法中绑定要读取的数据源
			FileInputStream fis = new FileInputStream("09_IOAndProperties\\b.txt");
			//2、使用FileInputStream对象中的方法read,读取文件
			byte[] bytes = new byte[1024];//存储读取到的多个字节
			int len = 0; //记录每次读取的有效字节个数
			while((len = fis.read(bytes))!=-1){
				//String(byte[] bytes, int offset, int length) 把字节数组的一部分转换为字符串 offset:数组的开始索引 length:转换的字节个数
				System.out.println(new String(bytes,0,len));
			}
			//3、释放资源
			fis.close();
	12、练习_文件复制
		1、文件复制练习:一读一写

		2、明确:
			数据源: c:\\1.jpg
			数据的目的地: d:\\1.jpg

		3、文件复制的步骤:
			1.创建一个字节输入流对象,构造方法中绑定要读取的数据源
			2.创建一个字节输出流对象,构造方法中绑定要写入的目的地
			3.使用字节输入流对象中的方法read读取文件
			4.使用字节输出流中的方法write,把读取到的字节写入到目的地的文件中
			5.释放资源(注意：先关闭写的(输出)，后关闭读的(输入)。因为如果写完了，肯定读取完毕了。但是读取完毕了却不一定写完了)
			
			
		4、代码案例：
			long t1 = System.currentTimeMillis();
			//1.创建一个字节输入流对象,构造方法中绑定要读取的数据源
			FileInputStream fis = new FileInputStream("E:\\test\\1\\3.png");
			//2.创建一个字节输出流对象,构造方法中绑定要写入的目的地
			FileOutputStream fos = new FileOutputStream("E:\\test\\2\\3.png");
			//3.使用字节输入流对象中的方法read(byte[])读取文件
			int len = 0;
			byte[] bytes = new byte[1024];
			while((len = fis.read(bytes)) != -1){
				//4.使用字节输出流中的方法write((byte[],0,len)),把读取到的字节写入到目的地的文件中
				fos.write(bytes,0,len);
			}
			//5.释放资源
			fos.close();
			fis.close();

			long t2 = System.currentTimeMillis();
			System.out.println("复制这个文件的时间是"+(t2-t1)+"毫秒");
			
			
		5、注意事项：
			1、使用System.currentTimeMillis()静态方法获取时间差值来比较效率
			2、使用len = read(byte[1024])的方法和write(byte[1024],0,len)的方法来提高文件复制效率
	13、使用字节流读取中文的问题
			1、使用字节流读取中文文件：1个中文
				GBK:占用两个字节
				UTF-8:占用3个字节
			2、解决方法：使用字符流读取和写出中文就不会出现乱码现象

	
05 IO字符流
	1、字符输入流_Reader类&FileReader类介绍
		1、java.io.Reader:字符输入流,是字符输入流的最顶层的父类,定义了一些共性的成员方法,是一个抽象类

		2、共性的成员方法:
			int read() 读取单个字符并返回。
			int read(char[] cbuf)一次读取多个字符,将字符读入数组。
			
			void close() 关闭该流并释放与之关联的所有资源。

		3、java.io.FileReader extends InputStreamReader extends Reader
			1、FileReader:文件字符输入流
				作用:把硬盘文件中的数据以字符的方式读取到内存中

			2、构造方法:
				1、FileReader(String fileName)
				2、FileReader(File file)
				3、参数:读取文件的数据源
					1、String fileName:文件的路径
					2、File file:一个文件
				4、FileReader构造方法的作用:
					1.创建一个FileReader对象
					2.会把FileReader对象指向要读取的文件
			3、字符输入流的使用步骤:
				1.创建FileReader对象,构造方法中绑定要读取的数据源
				2.使用FileReader对象中的方法read读取文件
				3.释放资源
	2、字符输入流读取字符数据
		1、创建FileReader对象,构造方法中绑定要读取的数据源
        FileReader fr = new FileReader("09_IOAndProperties\\c.txt");
		2、使用FileReader对象中的方法read(char[1024])读取文件
			char[] cs = new char[1024];//存储读取到的多个字符
			int len = 0;//记录的是每次读取的有效字符个数
			while((len = fr.read(cs))!=-1){
				/*
					String类的构造方法
					String(char[] value) 把字符数组转换为字符串
					String(char[] value, int offset, int count) 把字符数组的一部分转换为字符串 offset数组的开始索引 count转换的个数
				 */
				System.out.println(new String(cs,0,len));
			}
			
		3、释放资源：
			fr.close();
		4、注意事项：
			1、String类的构造方法：
				1、String(char[] value) 把字符数组转换为字符串
				2、String(char[] value, int offset, int count) 把字符数组的一部分转换为字符串 offset数组的开始索引 count转换的个数	
	3、_字符输出流_Writer类&FileWriter类介绍
		1、java.io.Writer:字符输出流,是所有字符输出流的最顶层的父类,是一个抽象类

		2、共性的成员方法:
			1、void write(int c) 写入单个字符。
			2、void write(char[] cbuf)写入字符数组。
			3、abstract  void write(char[] cbuf, int off, int len)写入字符数组的某一部分,off数组的开始索引,len写的字符个数。
			
			4、void write(String str)写入字符串。
			5、void write(String str, int off, int len) 写入字符串的某一部分,off字符串的开始索引,len写的字符个数。
			
			6、void flush()刷新该流的缓冲。
			7、void close() 关闭此流，但要先刷新它。

		3、java.io.FileWriter extends OutputStreamWriter extends Writer
			1、FileWriter:文件字符输出流
				作用:把内存中字符数据写入到文件中

			2、构造方法:
				1、FileWriter(File file)根据给定的 File 对象构造一个 FileWriter 对象。
				2、FileWriter(String fileName) 根据给定的文件名构造一个 FileWriter 对象。
				3、参数:写入数据的目的地
					1、String fileName:文件的路径
					2、File file:是一个文件
				4、构造方法的作用:
					1.会创建一个FileWriter对象
					2.会根据构造方法中传递的文件/文件的路径,创建文件
					3.会把FileWriter对象指向创建好的文件

			3、字符输出流的使用步骤(重点):
				1.创建FileWriter对象,构造方法中绑定要写入数据的目的地
				2.使用FileWriter中的方法write,把数据写入到内存缓冲区中(字符转换为字节的过程)
				3.使用FileWriter中的方法flush,把内存缓冲区中的数据,刷新到文件中
				4.释放资源(会先把内存缓冲区中的数据刷新到文件中)
	4、_字符输出流的基本使用_写出单个字符到文件
		1、字符输出流的使用步骤(重点):
			1.创建FileWriter对象,构造方法中绑定要写入数据的目的地
				FileWrite fw= new FileWrite("D:\IdeaProjects\basic\Demo0923\src\c.txt"); 
			2.使用FileWriter中的方法write,把数据写入到内存缓冲区中(字符转换为字节的过程)
				fw.write(97);
			3.使用FileWriter中的方法flush,把内存缓冲区中的数据,刷新到文件中
				fw.flush();
			4.释放资源(会先把内存缓冲区中的数据刷新到文件中)
				fw.close();
				
		2、注意事项：
			1、如果只是单纯的调用write()方法是没有把数据写出到文件中，只是把数据写到内存缓冲区中(存在字符转换为字节的情况)
			2、需要调用flush()方法把缓冲区中的数据刷新到文件中。
	5、flush方法和close方法的区别
        1、flush ：刷新缓冲区，流对象可以继续使用。
        2、close:  先刷新缓冲区，然后通知系统释放资源。流对象不可以再被使用了。
			注意：close方法之后流已经关闭了,已经从内存中消失了,流就不能再使用了。如果继续使用会抛出异常IOException，Stream close流已经关闭
	6、字符输出流写数据的其他方法
        1、void write(char[] cbuf)写入字符数组。
			char[] cs = {'a','b','c','d','e'};
			fw.write(cs);//abcde
        2、void write(char[] cbuf, int off, int len)写入字符数组的某一部分,off数组的开始索引,len写的字符个数。
			char[] cs = {'a','b','c','d','e'};
			fw.write(cs,1,3);//bcd
        3、void write(String str)写入字符串。
			fw.write("传智播客");//传智播客
        4、void write(String str, int off, int len) 写入字符串的某一部分,off字符串的开始索引,len写的字符个数。
			fw.write("黑马程序员",2,3);//程序员
	7、字符输出流的续写和换行
		1、续写,追加写:使用两个参数的构造方法
			FileWriter(String fileName, boolean append)
			FileWriter(File file, boolean append)
			参数:
				String fileName,File file:写入数据的目的地
				boolean append:续写开关 true:不会创建新的文件覆盖源文件,可以续写; false:创建新的文件覆盖源文件
		 2、换行:换行符号
			windows:\r\n
			linux:/n
			mac:/r
	8、使用try_catch_finally处理流中的异常
		1、在jdk1.7之前使用try catch finally 处理流中的异常
			格式:
				try{
					可能会产出异常的代码
				}catch(异常类变量 变量名){
					异常的处理逻辑
				}finally{
					一定会指定的代码
					资源释放
				}
		2、注意事项：
			1、资源释放的时候,必须流对象fw的作用域,让finally可以使用(因为局部变量的作用范围是{})
			2、变量在定义的时候,可以没有值,但是使用的时候必须有值(流对象定义的时候必须初始化,使用Null初始化)
			3、fw = new FileWriter("09_IOAndProperties\\g.txt",true); 执行失败,fw没有值,fw.close会报错
				所以在finally{}里面必须再使用try-catch来包裹着流对象释放资源的代码
			4、创建对象失败了,fw的默认值就是null,null是不能调用方法的,会抛出NullPointerException,需要增加一个判断,不是null在把资源释放
				if(fw!=null){
					try{}
					catch(IOException e){
						e.printStackTrace();
					}
				}
	9、JDK7和JDK9流中异常的处理
		1、JDK7的新特性
			1、在try的后边可以增加一个(),在括号中可以定义流对象，那么这个流对象的作用域就在try中有效
				try中的代码执行完毕,会自动把流对象释放,不用写finally
			2、格式:
				try(定义流对象;定义流对象....){
					可能会产出异常的代码
				}catch(异常类变量 变量名){
					异常的处理逻辑
				}
		2、JDK9新特性
			1、try的前边可以定义流对象，在try后边的()中可以直接引入流对象的名称(变量名)
				在try代码执行完毕之后,流对象也可以释放掉,不用写finally
			2、格式:
				A a = new A();
				B b = new B();
				try(a,b){
					可能会产出异常的代码
				}catch(异常类变量 变量名){
					异常的处理逻辑
				}
			3、注意事项：但是在try外面定义流对象，还是要处理异常。所以JDK9的新特性使用不方便
06 Properties集合
	1、使用Properties集合存储数据,遍历取出Properties集合中的数据
		1、java.util.Properties集合 extends Hashtable<k,v> implements Map<k,v>
		2、Properties 类表示了一个持久的属性集。Properties 可保存在流中或从流中加载。
			Properties集合是一个唯一和IO流相结合的集合
				1、可以使用Properties集合中的方法store,把集合中的临时数据,持久化写入到硬盘中存储
				2、可以使用Properties集合中的方法load,把硬盘中保存的文件(键值对),读取到集合中使用

		3、属性列表中每个键及其对应值都是一个字符串。
			Properties集合是一个双列集合,key和value默认都是字符串
			
			
			
		4、使用Properties集合存储数据,遍历取出Properties集合中的数据，Properties集合是一个双列集合,key和value默认都是字符串
			Properties集合有一些操作字符串的特有方法
				1、Object setProperty(String key, String value) 调用 Hashtable 的方法 put。
				2、String getProperty(String key) 通过key找到value值,此方法相当于Map集合中的get(key)方法
				3、Set<String> stringPropertyNames() 返回此属性列表中的键集，其中该键及其对应值是字符串,此方法相当于Map集合中的keySet方法
	2、Properties集合中的方法store
		1、可以使用Properties集合中的方法store,把集合中的临时数据,持久化写入到硬盘中存储
			1、void store(OutputStream out, String comments)
			2、void store(Writer writer, String comments)
        2、参数:
            1、OutputStream out:字节输出流,不能写入中文
            2、Writer writer:字符输出流,可以写中文
            3、String comments:注释,用来解释说明保存的文件是做什么用的
                    1、不能使用中文,会产生乱码,默认是Unicode编码
                    2、一般使用""空字符串

        3、使用步骤:
            1.创建Properties集合对象,添加数据
            2.创建字节输出流/字符输出流对象,构造方法中绑定要输出的目的地
            3.使用Properties集合中的方法store,把集合中的临时数据,持久化写入到硬盘中存储
            4.释放资源(使用匿名对象来创建流对象可以不用手动释放资源，因为默认自动的释放了)
			
			
		4、注意事项：
			1、使用字节输出流作为参数的时候，Properties的键值对不能为中文，否则会乱码(因为默认是使用Unicode码)
	3、Properties集合中的方法load(默认使用字节输入流)
		1、可以使用Properties集合中的方法load,把硬盘中保存的文件(键值对),读取到集合中使用
			1、void load(InputStream inStream)
			2、void load(Reader reader)
        2、参数:
            InputStream inStream:字节输入流,不能读取含有中文的键值对
            Reader reader:字符输入流,能读取含有中文的键值对
        3、使用步骤:
            1.创建Properties集合对象
            2.使用Properties集合对象中的方法load读取保存键值对的文件
            3.遍历Properties集合
        4、注意:
        *** 1.存储键值对的文件中,键与值默认的连接符号可以使用=,空格(其他符号)
            2.存储键值对的文件中,可以使用#进行注释,被注释的键值对不会再被读取
            3.存储键值对的文件中,键与值默认都是字符串,不用再加引号
			
			
			
			
			
			
			
			
			
			
			
			
		1、主要内容

			1、缓冲流
			2、转换流
			3、序列化流
			4、打印流


		2、教学目标

			1、能够使用字节缓冲流读取数据到程序
			2、能够使用字节缓冲流写出数据到文件
			3、能够明确字符缓冲流的作用和基本用法
			4、能够使用缓冲流的特殊功能
			5、能够阐述编码表的意义
			6、能够使用转换流读取指定编码的文本文件
			7、能够使用转换流写入指定编码的文本文件
			8、能够说出打印流的特点
			9、能够使用序列化流写出对象到文件
			10、能够使用反序列化流读取文件到程序中
	
07 缓冲流
	1、缓冲流的原理(内置的默认大小的缓冲区数组)
		1、昨天学习了基本的一些流，作为IO流的入门，今天我们要见识一些更强大的流。比如能够高效读写的缓冲流，能够转换编码的转换流，
			能够持久化存储对象的序列化流等等。这些功能更为强大的流，都是在基本的流对象基础之上创建而来的，就像穿上铠甲的武士一样，
			相当于是对基本流对象的一种增强。
		2、概述
			1、缓冲流,也叫高效流，是对4个基本的`FileXxx` 流的增强，所以也是4个流，按照数据类型分类：
				1、字节缓冲流(byte[] buf)：`BufferedInputStream`，`BufferedOutputStream` 
				2、字符缓冲流：`BufferedReader`，`BufferedWriter`

		3、缓冲流的基本原理，是在创建流对象时，会创建一个内置的默认大小的缓冲区数组，通过缓冲区读写，减少系统IO次数，从而提高读写的效率。
		
		
	2、BufferedOutputStream_字节缓冲输出流
		1、java.io.BufferedOutputStream extends FilterOutputStream extends OutputStream
			BufferedOutputStream:字节缓冲输出流

		2、继承自父类的共性成员方法:
			1、public void close() ：关闭此输出流并释放与此流相关联的任何系统资源。
			2、public void flush() ：刷新此输出流并强制任何缓冲的输出字节被写出。
			
			3、public void write(byte[] b)：将 b.length字节从指定的字节数组写入此输出流。
			4、public void write(byte[] b, int off, int len) ：从指定的字节数组写入 len字节，从偏移量 off开始输出到此输出流。
			5、public abstract void write(int b) ：将指定的字节输出流。
		3、构造方法:
			BufferedOutputStream(OutputStream out)  创建一个新的缓冲输出流，以将数据写入指定的底层输出流。
			BufferedOutputStream(OutputStream out, int size)  创建一个新的缓冲输出流，以将具有指定缓冲区大小的数据写入指定的底层输出流。
			参数:
			   1、OutputStream out:字节输出流
					我们可以传递FileOutputStream,缓冲流会给FileOutputStream增加一个缓冲区,提高FileOutputStream的写入效率
			   2、int size:指定缓冲流内部缓冲区的大小,不指定默认
		 4、使用步骤(重点)
			1.创建FileOutputStream对象,构造方法中绑定要输出的目的地
			2.创建BufferedOutputStream对象,构造方法中传递FileOutputStream对象对象,提高FileOutputStream对象效率
			3.使用BufferedOutputStream对象中的方法write,把数据写入到内部缓冲区中
			4.使用BufferedOutputStream对象中的方法flush,把内部缓冲区中的数据,刷新到文件中
			5.释放资源(会先调用flush方法刷新数据,第4步可以省略)
	3、BufferedInputStream_字节缓冲输入流
		1、java.io.BufferedInputStream extends FilterInputStream extends InputStream
			BufferedInputStream:字节缓冲输入流

		2、继承自父类的成员方法:
			1、int read()从输入流中读取数据的下一个字节。
			2、int read(byte[] b) 从输入流中读取一定数量的字节，并将其存储在缓冲区数组 b 中。
			3、void close() 关闭此输入流并释放与该流关联的所有系统资源。

		3、构造方法:
			1、BufferedInputStream(InputStream in) 创建一个 BufferedInputStream 并保存其参数，即输入流 in，以便将来使用。
			2、BufferedInputStream(InputStream in, int size) 创建具有指定缓冲区大小的 BufferedInputStream 并保存其参数，即输入流 in，以便将来使用。
			参数:
				InputStream in:字节输入流
					我们可以传递FileInputStream,缓冲流会给FileInputStream增加一个缓冲区,提高FileInputStream的读取效率
				int size:指定缓冲流内部缓冲区的大小,不指定默认

		4、使用步骤(重点):
			1.创建FileInputStream对象,构造方法中绑定要读取的数据源
			2.创建BufferedInputStream对象,构造方法中传递FileInputStream对象,提高FileInputStream对象的读取效率
			3.使用BufferedInputStream对象中的方法read,读取文件
			4.释放资源(释放资源只需要释放缓冲字节输入流就可以了，文件字节输入流在释放缓冲流的时候也默认释放了)
			
		5、注意事项：
			1、释放资源只需要释放缓冲字节输入流就可以了，文件字节输入流在释放缓冲流的时候也默认释放了
	4、缓冲流的效率测试_复制文件
		1、文件复制练习:一读一写

		2、明确:
			数据源: c:\\1.jpg
			数据的目的地: d:\\1.jpg
		3、文件复制的步骤:
			1.创建字节缓冲输入流对象,构造方法中传递字节输入流
			2.创建字节缓冲输出流对象,构造方法中传递字节输出流
			3.使用字节缓冲输入流对象中的方法read,读取文件
			4.使用字节缓冲输出流中的方法write,把读取的数据写入到内部缓冲区中
			5.释放资源(会先把缓冲区中的数据,刷新到文件中)

		4、文件的大小:780,831 字节
		5、一次读写一个字节:32毫秒
		6、使用数组缓冲读取多个字节,写入多个字节:5毫秒
		
		
		7、代码案例：
			long s = System.currentTimeMillis();
			//1.创建字节缓冲输入流对象,构造方法中传递字节输入流
			BufferedInputStream bis = new BufferedInputStream(new FileInputStream("c:\\1.jpg"));
			//2.创建字节缓冲输出流对象,构造方法中传递字节输出流
			BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream("d:\\1.jpg"));
			//3.使用字节缓冲输入流对象中的方法read,读取文件
			
			//一次读取一个字节写入一个字节的方式
			/*int len = 0;
			while((len = bis.read())!=-1){
				bos.write(len);
			}*/

			//使用数组缓冲读取多个字节,写入多个字节
			byte[] bytes = new byte[1024];
			int len = 0;
			while((len = bis.read(bytes))!=-1){
				bos.write(bytes,0,len);
			}

			bos.close();
			bis.close();

			long e = System.currentTimeMillis();
			System.out.println("复制文件共耗时:"+(e-s)+"毫秒");


	5、BufferedWriter_字符缓冲输出流
		1、java.lang.BufferedWriter extends Writer

		2、继承自父类的共性成员方法:
			1、void write(int c) 写入单个字符。
			2、void write(char[] cbuf)写入字符数组。
			3、abstract  void write(char[] cbuf, int off, int len)写入字符数组的某一部分,off数组的开始索引,len写的字符个数。
			4、void write(String str)写入字符串。
			5、void write(String str, int off, int len) 写入字符串的某一部分,off字符串的开始索引,len写的字符个数。
			6、void flush()刷新该流的缓冲。
			7、void close() 关闭此流，但要先刷新它。

		3、构造方法:
			1、BufferedWriter(Writer out) 创建一个使用默认大小输出缓冲区的缓冲字符输出流。
			2、BufferedWriter(Writer out, int sz) 创建一个使用给定大小输出缓冲区的新缓冲字符输出流。
			3、参数:
				1、Writer out:字符输出流
					我们可以传递FileWriter,缓冲流会给FileWriter增加一个缓冲区,提高FileWriter的写入效率
				2、int sz:指定缓冲区的大小,不写默认大小

		4、特有的成员方法(println方法的源码就是调用了newLine()方法):
			1、void newLine() 写入一个行分隔符。会根据不同的操作系统,获取不同的行分隔符
				1、换行:换行符号
					1、windows:\r\n
					2、linux:/n
					3、mac:/r
		 5、使用步骤:
			1.创建字符缓冲输出流对象,构造方法中传递字符输出流
			2.调用字符缓冲输出流中的方法write,把数据写入到内存缓冲区中
			3.调用字符缓冲输出流中的方法flush,把内存缓冲区中的数据,刷新到文件中
			4.释放资源
		6、代码案例：
			//System.out.println();
			//1.创建字符缓冲输出流对象,构造方法中传递字符输出流
			BufferedWriter bw = new BufferedWriter(new FileWriter("10_IO\\c.txt"));
			//2.调用字符缓冲输出流中的方法write,把数据写入到内存缓冲区中
			for (int i = 0; i <10 ; i++) {
				bw.write("传智播客");
				//bw.write("\r\n");
				bw.newLine();
			}
			//3.调用字符缓冲输出流中的方法flush,把内存缓冲区中的数据,刷新到文件中
			bw.flush();
			//4.释放资源
			bw.close();
	6、BufferedReader_字符缓冲输入流
		1、java.io.BufferedReader extends Reader
			BufferedReader:字符缓冲输入流

		2、继承自父类的共性成员方法:
			1、int read() 读取单个字符并返回。
			2、int read(char[] cbuf)一次读取多个字符,将字符读入数组。
			3、void close() 关闭该流并释放与之关联的所有资源。

		 3、构造方法:
			1、BufferedReader(Reader in)  创建一个使用默认大小输入缓冲区的缓冲字符输入流。
			2、BufferedReader(Reader in, int sz)     创建一个使用指定大小输入缓冲区的缓冲字符输入流。
			3、参数:
				Reader in:字符输入流
					我们可以传递FileReader,缓冲流会给FileReader增加一个缓冲区,提高FileReader的读取效率
		 4、特有的成员方法:
			1、String readLine() 读取一个文本行。读取一行数据
				行的终止符号:通过下列字符之一即可认为某行已终止：换行 ('\n')、回车 ('\r') 或回车后直接跟着换行(\r\n)。
			2、返回值:
				包含该行内容的字符串，不包含任何行终止符，如果已到达流末尾，则返回 null

		 5、使用步骤:
			1.创建字符缓冲输入流对象,构造方法中传递字符输入流
			2.使用字符缓冲输入流对象中的方法read/readLine读取文本
			3.释放资源
	7、练习_对文本的内容进行排序
        1、对文本的内容进行排序
			按照(1,2,3....)顺序排序
		2、分析:
			1.创建一个HashMap集合对象,可以:存储每行文本的序号(1,2,3,..);value:存储每行的文本
			2.创建字符缓冲输入流对象,构造方法中绑定字符输入流
			3.创建字符缓冲输出流对象,构造方法中绑定字符输出流
			4.使用字符缓冲输入流中的方法readline,逐行读取文本
			5.对读取到的文本进行切割,获取行中的序号和文本内容
			6.把切割好的序号和文本的内容存储到HashMap集合中(key序号是有序的,会自动排序1,2,3,4..)
			7.遍历HashMap集合,获取每一个键值对
			8.把每一个键值对,拼接为一个文本行
			9.把拼接好的文本,使用字符缓冲输出流中的方法write,写入到文件中
			10.释放资源
			
			
		3、注意事项：
			1、字符串的切割函数split(切割正则),参数是一个正则表达式。所以匹配"."需要使用"\\."
			2、遍历map集合有两种方式，一种是keySet()，另一种是entrySet()获取键值对对象的Set集合
				最后使用foreach循环遍历Set集合(使用map.keySet()或map.entrySet())
				for循环里面(keySet()使用map.get(),entrySet()使用entry.getKey()和entry.getValue())
	
08 转换流
	1、字符编码和字符集
		1、字符编码
			1、编码:字符(能看懂的)--字节(看不懂的)
			2、解码:字节(看不懂的)-->字符(能看懂的)
			
			3、字符编码(Character Encoding)： 就是一套自然语言的字符与二进制数之间的对应规则。
			4、编码表:生活中文字和计算机中二进制的对应规则
		
		2、字符集
			1、字符集(Charset)：也叫编码表。是一个系统支持的所有字符的集合，包括各国家文字、标点符号、图形符号、数字等。
			2、计算机要准确的存储和识别各种字符集符号，需要进行字符编码，一套字符集必然至少有一套字符编码。
				常见字符集有ASCII字符集、GBK字符集、Unicode字符集等。
				
			3、当指定了编码，它所对应的字符集自然就指定了，所以编码才是我们最终要关心的。
				1、ASCII字符集:ASCII编码
				2、GBK字符集:GBK编码
				3、Unicode字符集:UTF8编码、UTF16编码、UTF32编码
				
				注意事项：GBK编码中文存储2个字节,UTF8存储中文需要3个字节
			4、Unicode字符集的不同字符存储的字节个数不同
				1. 128个US-ASCII字符，只需一个字节编码。
				2. 拉丁文等字符，需要二个字节编码。 
				3. 大部分常用字（含中文），使用三个字节编码。
				4. 其他极少使用的Unicode辅助字符，使用四字节编码。
	2、编码引出的问题_FileReader读取GBK格式的文件
		1、FileReader可以读取IDE默认编码格式(UTF-8)的文件
		2、FileReader读取window系统默认编码(中文GBK)会产生乱码���
		3、在window系统创建文件并保存的时候选择ANSI保存(默认保存)的话，编码格式是GBK编码
	3、转换流的原理
		1、转换流是字节流与字符流之间的桥梁,负责字节的解码(不懂到懂)与字符编码(懂到不懂)的工作,这中间的对应规则由转换流规定的编码集负责
		2、转换流是字符流的子类,是文件字符流(FileReader和FileWriter)的父类
	4、OutputStreamWriter介绍&代码实现
		1、java.io.OutputStreamWriter extends Writer
			OutputStreamWriter: 是字符流通向字节流的桥梁：可使用指定的 charset 将要写入流中的字符编码成字节。(编码:把能看懂的变成看不懂)

		2、继承自父类的共性成员方法:
			1、void write(int c) 写入单个字符。
			2、void write(char[] cbuf)写入字符数组。
			3、abstract  void write(char[] cbuf, int off, int len)写入字符数组的某一部分,off数组的开始索引,len写的字符个数。
			4、void write(String str)写入字符串。
			5、void write(String str, int off, int len) 写入字符串的某一部分,off字符串的开始索引,len写的字符个数。
			6、void flush()刷新该流的缓冲。
			7、void close() 关闭此流，但要先刷新它。
		3、构造方法:
			1、OutputStreamWriter(OutputStream out)创建使用默认字符编码的 OutputStreamWriter。
			2、OutputStreamWriter(OutputStream out, String charsetName) 创建使用指定字符集的 OutputStreamWriter。
			3、参数:
				1、OutputStream out:字节输出流,可以用来写转换之后的字节到文件中
				2、String charsetName:指定的编码表名称,不区分大小写,可以是utf-8/UTF-8,gbk/GBK,...不指定默认使用UTF-8
		4、使用步骤:
			1.创建OutputStreamWriter对象,构造方法中传递字节输出流和指定的编码表名称
			2.使用OutputStreamWriter对象中的方法write,把字符转换为字节存储缓冲区中(编码)
			3.使用OutputStreamWriter对象中的方法flush,把内存缓冲区中的字节刷新到文件中(使用字节流写字节的过程)
			4.释放资源
	5、InputStreamReader介绍&代码实现
		1、java.io.InputStreamReader extends Reader
			InputStreamReader:是字节流通向字符流的桥梁：它使用指定的 charset 读取字节并将其解码为字符。(解码:把看不懂的变成能看懂的)

		2、继承自父类的共性成员方法:
			int read() 读取单个字符并返回。
			int read(char[] cbuf)一次读取多个字符,将字符读入数组。
			void close() 关闭该流并释放与之关联的所有资源。
		3、构造方法:
			1、InputStreamReader(InputStream in) 创建一个使用默认字符集的 InputStreamReader。
			2、InputStreamReader(InputStream in, String charsetName) 创建使用指定字符集的 InputStreamReader。
			3、参数:
				1、InputStream in:字节输入流,用来读取文件中保存的字节
				2、String charsetName:指定的编码表名称,不区分大小写,可以是utf-8/UTF-8,gbk/GBK,...不指定默认使用UTF-8
		4、使用步骤:
			1.创建InputStreamReader对象,构造方法中传递字节输入流和指定的编码表名称
			2.使用InputStreamReader对象中的方法read读取文件
			3.释放资源
	***	5、注意事项:
			构造方法中指定的编码表名称要和文件的编码相同,否则会发生乱码
	6、练习_转换文件编码
		 1、练习：转换文件编码
			将GBK编码的文本文件，转换为UTF-8编码的文本文件。

		2、分析:
			1.创建InputStreamReader对象,构造方法中传递字节输入流和指定的编码表名称GBK
			2.创建OutputStreamWriter对象,构造方法中传递字节输出流和指定的编码表名称UTF-8
			3.使用InputStreamReader对象中的方法read读取文件
			4.使用OutputStreamWriter对象中的方法write,把读取的数据写入到文件中
			5.释放资源
09 序列化流
	1、序列化和反序列化的概述
		1、Java 提供了一种对象序列化的机制。用一个字节序列可以表示一个对象，该字节序列包含该"对象的数据"、"对象的类型"和"对象中存储的属性"等信息。
			字节序列写出到文件之后，相当于文件中"持久保存"了一个对象的信息。 
			反之，该字节序列还可以从文件中读取回来，重构对象，对它进行"反序列化"。"对象的数据"、"对象的类型"和"对象中存储的数据"信息，都可以用来在内存中创建对象。
			
		2、对象的序列化：ObjectOutputSteam序列化流
			ObjectInputStream extends InputStream
		3、对象的反序列化:ObjectInputStream反序列化流
			ObjectOutputStream extends OutputStream
	2、对象的序列化流_ObjectOutputStream
		1、java.io.ObjectOutputStream extends OutputStream
			ObjectOutputStream:对象的序列化流
		2、作用:把对象以流的方式写入到文件中保存

		3、构造方法:
			ObjectOutputStream(OutputStream out) 创建写入指定 OutputStream 的 ObjectOutputStream。
			参数:OutputStream out:字节输出流
		4、特有的成员方法:
			void writeObject(Object obj) 将指定的对象写入 ObjectOutputStream。

		5、使用步骤:
			1.创建ObjectOutputStream对象,构造方法中传递字节输出流
			2.使用ObjectOutputStream对象中的方法writeObject,把对象写入到文件中
			3.释放资源
		6、序列化和反序列化的时候,会抛出NotSerializableException没有序列化异常
			1、类通过实现 java.io.Serializable 接口以启用其序列化功能。未实现此接口的类将无法使其任何状态序列化或反序列化。
			2、Serializable接口也叫标记型接口,要进行序列化和反序列化的类必须实现Serializable接口,就会给类添加一个标记
				当我们进行序列化和反序列化的时候,就会检测类上是否有这个标记
					、有:就可以序列化和反序列化
					2、没有:就会抛出 NotSerializableException异常
	3、对象的反序列化流_ObjectInputStream
		1、java.io.ObjectInputStream extends InputStream
			ObjectInputStream:对象的反序列化流
		2、作用:把文件中保存的对象,以流的方式读取出来使用

		3、构造方法:
			ObjectInputStream(InputStream in) 创建从指定 InputStream 读取的 ObjectInputStream。
			参数:InputStream in:字节输入流
		4、特有的成员方法:
			Object readObject() 从 ObjectInputStream 读取对象。

		5、使用步骤:
			1.创建ObjectInputStream对象,构造方法中传递字节输入流
			2.使用ObjectInputStream对象中的方法readObject读取保存对象的文件
			3.释放资源
			4.使用读取出来的对象(打印)

		6、readObject方法声明抛出了ClassNotFoundException(class文件找不到异常)
			当不存在对象的class文件时抛出此异常
		7、反序列化的前提:
			1.类必须实现Serializable
			2.必须存在类对应的class文件
	4、transient关键字_瞬态关键字
		1、static关键字:静态关键字
			静态优先于非静态加载到内存中(静态优先于对象进入到内存中),故被static修饰的成员变量不能被序列化的,序列化的都是对象
			private static int age;
			oos.writeObject(new Person("小美女",18));
			Object o = ois.readObject();
			Person{name='小美女', age=0}

		2、transient关键字:瞬态关键字
			被transient修饰成员变量,不能被序列化。但是又没有静态关键字的含义。瞬态关键字作用只是让特定的变量不被序列化而已，但是又没有静态关键字的含义
			private transient int age;
			oos.writeObject(new Person("小美女",18));
			Object o = ois.readObject();
			Person{name='小美女', age=0}
	5、InvalidClassException异常_原理和解决方案
		1、实现Serializable接口的类，会根据类的定义给对应的class文件，添加一个序列号(serialVersionUID)
			序列化之后的文件中也复制class文件中的序列号(serialVersionUID)到txt文件中
			反序列化的时候会把class文件中的序列号(serialVersionUID)和文本文件中的序列号(serialVersionUID)进行比较。
			如果不一样的话会抛出InvalidClassException序列化冲突异常
		2、问题：每次修改类的定义，都会给class文件生成新的一个序列号
		3、解决方案：无论是否给类的定义重新修改，都不生成新的序列号。可以手动给类添加一个序列号
		4、序列号格式：
			可序列化类可以通过声明名为 "serialVersionUID" 的字段
			（该字段必须是静态 (static)、最终 (final) 的 long 型字段）显式声明其自己的 serialVersionUID：
			
			static final long serialVersionUID = 42L;//常量不可改变
	6、练习_序列化集合
		1、练习：序列化集合
			当我们想在文件中保存多个对象的时候
			可以把多个对象存储到一个集合中
			对集合进序列化和反序列化
		2、分析:
			1.定义一个存储Person对象的ArrayList集合
			2.往ArrayList集合中存储Person对象
			3.创建一个序列化流ObjectOutputStream对象
			4.使用ObjectOutputStream对象中的方法writeObject,对集合进行序列化
			5.创建一个反序列化ObjectInputStream对象
			6.使用ObjectInputStream对象中的方法readObject读取文件中保存的集合
			7.把Object类型的集合转换为ArrayList类型
			8.遍历ArrayList集合
			9.释放资源
10 打印流
	1、打印流_概述和使用
		1、java.io.PrintStream:打印流
			PrintStream 为其他输出流添加了功能，使它们能够方便地打印各种数据值表示形式。
		2、PrintStream特点:
			1.只负责数据的输出,不负责数据的读取
			2.与其他输出流不同，PrintStream 永远不会抛出 IOException
			3.有特有的方法,print,println
				void print(任意类型的值)
				void println(任意类型的值并换行)
		3、构造方法:
			1、PrintStream(File file):输出的目的地是一个文件
			2、PrintStream(OutputStream out):输出的目的地是一个字节输出流
			3、PrintStream(String fileName) :输出的目的地是一个文件路径
		4、PrintStream extends FilterOutputStream extends OutputStream
		5、继承自OutputStream的成员方法:
			1、public void close() ：关闭此输出流并释放与此流相关联的任何系统资源。
			2、public void flush() ：刷新此输出流并强制任何缓冲的输出字节被写出。
			3、public void write(byte[] b)：将 b.length字节从指定的字节数组写入此输出流。
			4、public void write(byte[] b, int off, int len) ：从指定的字节数组写入 len字节，从偏移量 off开始输出到此输出流。
			5、public abstract void write(int b) ：将指定的字节输出流。
		6、注意:
			如果使用继承自父类的write方法写数据,那么查看数据的时候会查询编码表 97->a
			如果使用自己特有的方法print/println方法写数据,写的数据原样输出 97->97
			
			
			
		7、System类
			1、System.out:public final static PrintStream out = null;//底层源码是一个打印流
			2、System.in:public final static InputStream in = null;//底层源码是一个字节输入流
			3、可以改变输出语句的目的地(打印流的流向):System.out.println()
				1、输出语句,默认在控制台输出
				2、使用System.setOut方法改变输出语句的目的地改为参数中传递的打印流的目的地
					static void setOut(PrintStream out):重新分配“标准”输出流。