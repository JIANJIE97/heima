第1节 异常
	02_异常概念&异常体系
		1、java.lang.Throwable:类是 Java 语言中所有错误或异常的超类。
        2、Exception:是Throwable的子类，编译期异常,进行编译(写代码)java程序出现的问题
            1、RuntimeException:运行期异常,java程序运行过程中出现的问题
            异常就相当于程序得了一个小毛病(感冒,发烧),把异常处理掉,程序可以继续执行(吃点药,继续革命工作)
			
			2、RuntimeException是Exception的特殊的子类：运行期异常，程序运行期间抛出的异常
        3、Error:错误是Throwable的子类
            错误就相当于程序得了一个无法治愈的毛病(非典,艾滋).必须修改源代码,程序才能继续执行
	03_异常分类
		1、处理出现异常的两种方式：
			1、直接抛出异常给JVM处理（JVM会中断执行并打印异常）。在出现异常的方法后面加上：throws 对应异常的名称
			2、使用try-catch方式来处理异常。好处是可以不中断程序的执行。可以继续执行程序
				try{
					//可能出现异常的代码
				}catch(Exception e){
					//处理异常的代码块
					e.printStackTrace();
				}
				
		2、Error错误：
			OutOfMemoryError:Java heap space
			内存溢出的错误，创建的数组太大了，超出了给JVM分配的内存
		3异常的分类：根据在编译时期还是运行时期去检查异常
			1、运行时期异常(RuntimeException):在运行时期,检查异常.在编译时期,运行异常不会编译器检测(不报错)。(如数学异常)。
				可以不处理，默认给JVM处理(打印异常对象、中断程序)
				
				例如：空指针异常、数组下标越界异常
			2、编译时期异常：checked异常。在编译时期,就会检查,如果没有处理异常,则编译失败。(如日期格式化异常)
				我们必须处理这个异常，处理方式要么是throws，要么try-catch

	04_异常的产生过程解析(分析异常的怎么产生的,如何处理异常)
		抛出异常：
			1、自己抛出(在方法内throw new Exception/Exception子类)
			2、JVM抛出(JVM自己抛出)
		处理异常：
			1、交给别人处理(使用throws Exception/Exception子类 声明异常对象并最终交给JVM处理<打印异常对象并中断程序>)
			2、自己处理(使用try-catch处理)
			
			
			
		数组越界异常解析(JVM抛出异常+JVM处理异常)：
		1、第一步：当访问数组中的索引时，而当数组中没有该索引时，JVM就会检测出程序会出现异常
			JVM会做两件事：
				1、JVM会根据异常产生的原因创建一个异常对象，这个对象包含了异常产生的（内容、原因、位置）
					new ArrayIndexOutOfBoundsException("原因/位置");
				2、在发生异常的方法中，没有异常的处理逻辑(try-catch),那么JVM就会把异常对象抛出给方法的调用者所在的方法main方法来处理这个异常
		2、第二步：main方法接收到了这个异常对象，main方法也没有异常的处理逻辑，继续把异常对象抛出给mian方法的调用则JVM	来处理
		3、第三步：
			JVM接收到这个异常对象，做了两件事	
				1、把异常对象(内容、原因、位置)以红色的字体打印在控制台
				2、JVM会终止当前正在执行的java程序-->中断处理
			
	05_throw关键字
		1、Java异常处理的五个关键字：try-catch(自己处理异常的方式)\throw(在方法内自己抛出异常)\throws(声明这个异常并抛出异常给JVM处理)\finally
		2、throw作用:
			可以使用throw关键字在指定的方法中抛出指定的异常
		3、throw使用格式:
			throw new xxxException("异常产生的原因");
		4、throw注意:
			1.throw关键字必须写在方法的内部
			2.throw关键字后边new的对象必须是Exception或者Exception的子类对象
			3.throw关键字抛出指定的异常对象,我们就必须处理这个异常对象
				throw关键字后边创建的是RuntimeException或者是 RuntimeException的子类对象,我们可以不处理,默认交给JVM处理(打印异常对象,中断程序)
				throw关键字后边创建的是编译异常(写代码的时候报错),我们就必须处理这个异常,要么throws,要么try...catch
				
				
				
		5、例子解析：以后(工作中)我们首先必须对方法传递过来的参数进行合法性校验
			如果参数不合法,那么我们就必须使用抛出异常的方式,告知方法的调用者,传递的参数有问题。
			1、注意:
				NullPointerException是一个运行期异常,我们不用处理,默认交给JVM处理
				ArrayIndexOutOfBoundsException是一个运行期异常,我们不用处理,默认交给JVM处理
				
			2、空指针异常
				/*
					我们可以对传递过来的参数数组,进行合法性校验
					如果数组arr的值是null
					那么我们就抛出空指针异常,告知方法的调用者"传递的数组的值是null"
				 */
				if(arr == null){
					throw new NullPointerException("传递的数组的值是null");
				}
			3、数组下标越界异常
				/*
					我们可以对传递过来的参数index进行合法性校验
					如果index的范围不在数组的索引范围内
					那么我们就抛出数组索引越界异常,告知方法的调用者"传递的索引超出了数组的使用范围"
				 */
				if(index<0 || index>arr.length-1){
					throw new ArrayIndexOutOfBoundsException("传递的索引超出了数组的使用范围");
				}
	06_Objects非空判断_requireNonNull方法
		1、Obects类中的静态方法：
			public static <T> T requireNonNull(T obj):查看指定引用对象不是null。
		2、源码:
        public static <T> T requireNonNull(T obj) {
            if (obj == null)
                throw new NullPointerException();
            return obj;
        }
		3、例子：
			1、Objects.requireNonNull(obj);
			2、Objects.requireNonNull(obj,"传递的对象的值是null");
	07_throws关键字_异常处理的第一种方式,交给别人处理
		1、作用:
			当方法内部抛出异常对象的时候,那么我们就必须处理这个异常对象
			可以使用throws关键字处理异常对象,会把异常对象声明抛出给方法的调用者处理(自己不处理,给别人处理),最终交给JVM处理-->中断处理
		2、使用格式:在方法声明时使用
			修饰符 返回值类型 方法名(参数列表) throws AAAExcepiton,BBBExcepiton...{
				throw new AAAExcepiton("产生原因");
				throw new BBBExcepiton("产生原因");
				...
			}
		3、注意:
			1.throws关键字必须写在方法声明处
			2.throws关键字后边声明的异常必须是Exception或者是Exception的子类
			3.方法内部如果抛出了多个异常对象,那么throws后边必须也声明多个异常
				如果抛出的多个异常对象有子父类关系,那么直接声明父类异常即可
		***	4.调用了一个声明抛出异常的方法,我们就必须的处理声明的异常
				1、要么继续使用throws声明抛出,交给方法的调用者处理,最终交给JVM
				2、要么try...catch自己处理异常
				
		4、例子：
			FileNotFoundException extends IOException extends Excepiton
			如果抛出的多个异常对象有子父类关系,那么直接声明父类异常即可
			
			public static void main(String[] args) throws IOException{}
	08_try_catch_异常处理的第二种方式,自己处理异常
		1、格式:
			try{
				可能产生异常的代码
			}catch(定义一个异常的变量,用来接收try中抛出的异常对象){//try中抛出什么异常对象,catch就定义什么异常变量,用来接收这个异常对象
				异常的处理逻辑,异常异常对象之后,怎么处理异常对象
				一般在工作中,会把异常的信息记录到一个日志中
			}
			...
			catch(异常类名 变量名){
				//异常处理逻辑
			}
		2、注意:
			1.try中可能会抛出多个异常对象,那么就可以使用多个catch来处理这些异常对象
			2.如果try中产生了异常,那么就会执行catch中的异常处理逻辑,执行完毕catch中的处理逻辑,继续执行try...catch之后的代码
			  如果try中没有产生异常,那么就不会执行catch中异常的处理逻辑,执行完try中的代码,继续执行try...catch之后的代码
	09_Throwable类中3个异常处理的方法
		1、Throwable类中定义了3个异常处理的方法
			1、String getMessage() 返回此 throwable 的简短描述。
			2、String toString() 返回此 throwable 的详细消息字符串。
			3、void printStackTrace()  JVM打印异常对象,默认此方法,打印的异常信息是最全面的·
			
			
		2、例子：
			//System.out.println(e.getMessage());//文件的后缀名不对
            //System.out.println(e.toString());//重写Object类的toString java.io.IOException: 文件的后缀名不对
            //System.out.println(e);//java.io.IOException: 文件的后缀名不对

            /*
                java.io.IOException: 文件的后缀名不对
                    at com.itheima.demo02.Exception.Demo01TryCatch.readFile(Demo01TryCatch.java:55)
                    at com.itheima.demo02.Exception.Demo01TryCatch.main(Demo01TryCatch.java:27)
             */
	10_finally代码块
		1、格式:
			try{
				可能产生异常的代码
			}catch(定义一个异常的变量,用来接收try中抛出的异常对象){
				异常的处理逻辑,异常异常对象之后,怎么处理异常对象
				一般在工作中,会把异常的信息记录到一个日志中
			}
			...
			catch(异常类名 变量名){

			}finally{
				无论是否出现异常都会执行
			}
		2、注意:
			1.finally不能单独使用,必须和try一起使用
			2.finally一般用于资源释放(资源回收),无论程序是否出现异常,最后都要资源释放(IO)
	11_异常注意事项_多异常的捕获处理
		1. 多个异常分别处理。(每次可能出现异常的地方都try-catch一次)
		2. 多个异常一次捕获，多次处理。(最常用：一次捕获，多次处理即一个try多个catch)
		3. 多个异常一次捕获一次处理。(catch捕获的时候使用所有异常的共同父类)
		
		
		注意事项：
			1、一个try多个catch注意事项:
                catch里边定义的异常变量,如果有子父类关系,那么子类的异常变量必须写在上边,否则就会报错(因为如果父类在上面就会形成多态,后面的子类就都不起作用了)
                ArrayIndexOutOfBoundsException extends IndexOutOfBoundsException
				
			2、"运行时异常"被抛出可以不处理。即不捕获也不声明抛出。(默认给JVM处理)
				默认给虚拟机处理,终止程序,什么时候不抛出运行时异常了,在来继续执行程序
	12_异常注意事项_finally有return语句
		如果finally有return语句,那么就会永远返回finally中的结果,应该避免这种情况.
	13_异常注意事项_子父类异常
		1、子父类的异常:
			1、如果父类抛出了多个异常,子类重写父类方法时,
				1、抛出和父类相同的异常
				2、是父类异常的子类
				3、不抛出异常。
			2、父类方法没有抛出异常，子类重写父类该方法时也不可抛出异常。
				此时子类产生该异常，只能捕获处理，不能声明抛出
		2、注意:
			父类异常时什么样,子类异常就什么样
	14_自定义异常类
        java提供的异常类,不够我们使用,需要自己定义一些异常类
		1、格式:
			public class XXXExcepiton extends Exception | RuntimeException{
				//添加一个空参数的构造方法
				public XXXExcepiton(){
					super();
				}
				//添加一个带异常信息的构造方法
				public XXXExcepiton(String message){
					/*
						添加一个带异常信息的构造方法
						查看源码发现,所有的异常类都会有一个带异常信息的构造方法,
						方法内部会调用父类带异常信息的构造方法,
						让父类来处理这个异常信息
					 */
					super(message);
				}
			}
		2、注意:
			1.自定义异常类一般都是以Exception结尾,说明该类是一个异常类
			2.自定义异常类,必须的继承Exception或者RuntimeException
				继承Exception:那么自定义的异常类就是一个编译期异常,如果方法内部抛出了编译期异常,就必须处理这个异常,要么throws,要么try...catch
				继承RuntimeException:那么自定义的异常类就是一个运行期异常,无需处理,交给虚拟机处理(中断处理)
	15_自定义异常类的练习
		1、要求：我们模拟注册操作，如果用户名已存在，则抛出异常并提示：亲，该用户名已经被注册。
		2、分析:
			1.使用数组保存已经注册过的用户名(数据库)
			2.使用Scanner获取用户输入的注册的用户名(前端,页面)
			3.定义一个方法,对用户输入的中注册的用户名进行判断
				遍历存储已经注册过用户名的数组,获取每一个用户名
				使用获取到的用户名和用户输入的用户名比较
					true:
						用户名已经存在,抛出RegisterException异常,告知用户"亲，该用户名已经被注册";
					false:
						继续遍历比较
				如果循环结束了,还没有找到重复的用户名,提示用户"恭喜您,注册成功!";
第2节 线程实现方式
		我们在之前，学习的程序在没有跳转语句的前提下，都是由上至下依次执行，那现在想要设计一个程序，边打游戏边听歌，怎么设计？
			要解决上述问题,咱们得使用多进程或者多线程来解决.
	16_并发与并行
		并发(交替执行)：指两个或多个事件在**同一个时间段内**发生。
		并行(同时执行)：指两个或多个事件在**同一时刻**发生（同时发生）。并行比并发快
	17_进程概念(进入到内存的程序叫做进程)
		1、是指一个内存中运行的应用程序，每个进程都有一个独立的内存空间，一个应用程序可以同时运行多个进程；
		2、进程也是程序的一次执行过程，是系统运行程序的基本单位；
		3、系统运行一个程序即是一个进程从创建、运行到消亡的过程。
	18_线程概念
		1、线程是进程中的一个执行单元，负责当前进程中程序的执行(一个进程中至少有一个线程)。
		2、一个进程中是可以有多个线程的，这个应用程序也可以称之为多线程程序。 
		
		
		简而言之：一个程序运行后至少有一个进程，一个进程中可以包含多个线程 
		
		
		
		3、cpu：
			1、cpu:中央处理器，对数据进行计算，指挥电脑中的软件和硬件干活
			2、cpu的分类：
				1、AMD
				2、Inter:Inter Core(核心) i7 8866 4核8线程
					8线程：同时执行8个任务
			3、不同核心的cpu运行区别
				1、单核心单线程的cpu:
					cpu在多个线程之间做高速的切换，轮流执行多个线程。效率低
				2、4核心8线程的cpu:
					速度是单线程的cpu的8倍
					
		4、程序运行时对进程和线程的解析：
			1、程序点击运行,程序会进入到内存中，这就是一个进程
			2、点击程序中的功能执行，就会开启一条应用程序到cpu的执行路径，cpu就可以通过这条路径执行功能。这个路径就叫做线程
		5、多线程的好处：
			1、效率高
			2、多个线程之间互不影响
	19_线程调度
		1、分时调度
			所有线程轮流使用 CPU 的使用权，平均分配每个线程占用 CPU 的时间。
		2、抢占式调度
		  优先让优先级高的线程使用 CPU，如果线程的优先级相同，那么会随机选择一个(线程随机性)，Java使用的为抢占式调度。
		  
		3、抢占式调度详解
			1、大部分操作系统都支持多进程并发运行，现在的操作系统几乎都支持同时运行多个程序。
				比如：现在我们上课一边使用编辑器，一边使用录屏软件，同时还开着画图板，dos窗口等软件。
				此时，这些程序是在同时运行，”感觉这些软件好像在同一时刻运行着“。
			2、实际上，CPU(中央处理器)使用抢占式调度模式在多个线程间进行着高速的切换。
				对于CPU的一个核而言，某个时刻，只能执行一个线程，而 CPU的在多个线程间切换速度相对我们的感觉要快，
				看上去就是在同一时刻运行。其实，多线程程序并不能提高程序的运行速度，但能够提高程序运行效率，让CPU的使用率更高。
	20_主线程
		1、主线程:执行主(main)方法的线程
		2、单线程程序:java程序中只有一个线程
			执行从main方法开始,从上到下依次执行
		3、JVM执行main方法,main方法会进入到栈内存
			JVM会找操作系统开辟一条main方法通向cpu的执行路径
			cpu就可以通过这个路径来执行main方法
			而这个路径有一个名字,叫main(主)线程
	21_创建多线程程序的第一种方式_创建Thread类的子类(1、创建Thread的子类2、创建子类的对象3、通过子类对象启动多线程)
		1、java.lang.Thread类:是描述线程的类,我们想要实现多线程程序,就必须继承Thread类
		2、实现步骤:
			1.创建一个Thread类的子类
			2.在Thread类的子类中重写Thread类中的run方法,设置线程任务(开启线程要做什么?)
			3.创建Thread类的子类对象
			4.调用Thread类中的方法start方法,开启新的线程,执行run方法
				 void start() 使该线程开始执行；Java 虚拟机调用该线程的 run 方法。
				 结果是两个线程并发地运行；当前线程（main线程）和另一个线程（创建的新线程,执行其 run 方法）。
				 多次启动一个线程是非法的。特别是当线程已经结束执行后，不能再重新启动。
		3、java程序属于抢占式调度,那个线程的优先级高,那个线程优先执行;同一个优先级,随机选择一个执行
	
	
	
	【
		1、能够描述Java中多线程运行原理
		2、能够使用继承类的方式创建多线程
		3、能够使用实现接口的方式创建多线程
		4、能够说出实现接口方式的好处
		5、能够解释安全问题的出现的原因
		6、能够使用同步代码块解决线程安全问题
		7、能够使用同步方法解决线程安全问题
		8、能够说出线程6个状态的名称
	 】
	 
	 
	构造方法：
		1、public Thread() :分配一个新的线程对象。
		2、public Thread(String name) :分配一个指定名字的新的线程对象。
		3、public Thread(Runnable target) :分配一个带有指定目标新的线程对象。
		4、public Thread(Runnable target,String name) :分配一个带有指定目标新的线程对象并指定名字。
	常用方法：
		1、public String getName() :获取当前线程名称。
		2、public void start() :导致此线程开始执行; Java虚拟机调用此线程的run方法。
		3、public void run() :此线程要执行的任务在此处定义代码。
		4、public static void sleep(long millis) :使当前正在执行的线程以指定的毫秒数暂停
		5、public static Thread currentThread() :返回对当前正在执行的线程对象的引用。


	22_多线程原理_随机性打印结果
		1、JVM执行main方法，找os操作系统开辟一条main方法通向cpu的路径。这个路径叫main线程，主线程（cpu通过这个路径/线程可以执行main方法）
		2、开辟一条通向cpu的新路径。(当新线程对象调用start()时，cpu执行run方法)
		
		3、对于cpu而言，有了两条执行路径，cpu就有了选择的权利
			两个线程，一个main线程，一个新线程，一起抢夺执行权（执行时间）。谁抢到了谁执行相对应的代码
	23_多线程原理_多线程内存图解(每一个线程都有自己的独立栈空间)
		1、java命令之后由JVM完成main线程的开启一个main的栈空间
		2、新线程对象调用start():
			就是通知JVM要开辟新的线程空间了。并且要求在新的栈空间中执行线程对象的run方法。
		3、存在多个栈空间，cpu就有了选择的权利。可以执行主线程也可以执行另外的新线程
			多线程的好处：多个线程之间互不影响(在不同的栈空间)
	24_Thread类的常用方法_获取线程名称的方法
        1.使用Thread类中的方法getName()
            String getName() 返回该线程的名称。
        2.可以先获取到当前正在执行的线程(Thread类的子类),使用线程中的方法getName()获取线程的名称
            static Thread currentThread() 返回对当前正在执行的线程对象的引用。
	25_Thread类的常用方法_设置线程名称的方法
		设置线程的名称:(了解)
        1.使用Thread类中的方法setName(名字)
            void setName(String name) 改变线程名称，使之与参数 name 相同。
        2.创建一个带参数的构造方法,参数传递线程的名称;调用父类的带参构造方法,把线程名称传递给父类,让父类(Thread)给子线程起一个名字
            Thread(String name) 分配新的 Thread 对象。
	26_Thread类的常用方法_sleep
		1、public static void sleep(long millis):使当前正在执行的线程以指定的毫秒数暂停（暂时停止执行）。
			毫秒数结束之后,线程继续执行
		2、例子：
			//使用Thread类的sleep方法让程序睡眠1秒钟
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
	27_创建多线程程序的第二种方式_实现Runnable接口
		1、java.lang.Runnable
			Runnable 接口应该由那些打算通过某一线程执行其实例的类来实现。类必须定义一个称为 run 的无参数方法。
		2、java.lang.Thread类的构造方法
			Thread(Runnable target) 分配新的 Thread 对象。
			Thread(Runnable target, String name) 分配新的 Thread 对象。

		3、实现步骤(1、创建实现类2、创建实现类对象3、通过实现类对象给Thread类启动线程):
			1.创建一个Runnable接口的实现类
			2.在实现类中重写Runnable接口的run方法,设置线程任务
			3.创建一个Runnable接口的实现类对象
			4.创建Thread类对象,构造方法中传递Runnable接口的实现类对象
			5.调用Thread类中的start方法,开启新的线程执行run方法
	28_Thread和Runnable的区别
		实现Runnable接口创建多线程程序的好处:
        1.避免了单继承的局限性
            一个类只能继承一个类(一个人只能有一个亲爹),类继承了Thread类就不能继承其他的类
            实现了Runnable接口,还可以继承其他的类,实现其他的接口
        2.增强了程序的扩展性,降低了程序的耦合性(解耦)
            实现Runnable接口的方式,把设置线程任务和开启新线程进行了分离(解耦)：
				1、实现类中,重写了run方法:用来设置线程任务
				2、创建Thread类对象,调用start方法:用来开启新线程
			1、因为使用继承子类的方式时，设置线程任务的run()方法和线程启动方法start()方法都是Thread类的成员方法。
			2、即可以通过不同的实现类对象(重写的run方法也不同,不同的线程)，来创建Thread类对象。再通过Thread类对象来启动多线程。
	29_匿名内部类方式实现线程的创建
		1、匿名:没有名字
		2、内部类:写在其他类内部的类

		3、匿名内部类作用:简化代码
			1、把子类继承父类,重写父类的方法,创建子类对象合一步完成
			2、把实现类实现类接口,重写接口中的方法,创建实现类对象合成一步完成
		4、匿名内部类的最终产物:子类/实现类对象,而这个类没有名字

	***	5、格式:
			new 父类/接口(){
				重复父类/接口中的方法
			};
		6、例子：
			//1、匿名内部类
			new Thread(){
				@Override
				public void run() {
					for (int i = 0; i < 20; i++) {
						System.out.println(Thread.currentThread().getName()+"匿名内部类"+i);
					}
				}
			}.start();
			//2、匿名内部接口
			new Thread(new Runnable(){
				@Override
				public void run() {
					for (int i = 0; i < 20; i++) {
						System.out.println(Thread.currentThread().getName()+"匿名内部接口"+i);
					}
				}
			}).start();
第3节 线程同步机制
	1_线程安全问题的概述
		1、概述：
			如果有多个线程在同时运行，而这些线程可能会同时运行这段代码。程序每次运行结果和单线程运行的结果是一样
			的，而且其他的变量的值也和预期的是一样的，就是线程安全的。
		2、解析：
			1、单线程程序是不会出现线程安全的
			2、多线程程序，没有访问共享数据，也不会产生线程安全问题
			3、多线程访问了共享的数据，会产生线程安全问题
		3、电影院卖票线程安全问题例子：
			出现线程安全问题：
				1. 相同的票数,比如5这张票被卖了两回。（出现了重复的票）
				2. 不存在的票，比如0票与-1票，是不存在的。（出现了不存在的票）


	2_线程安全问题的代码实现
		1、Runnable接口实现类
			private int ticket = 100;
			@Override
			public void run() {
				while(true){

					//为了提高线程出现问题的概率，让程序睡眠
					try {
						Thread.sleep(10);
					} catch (InterruptedException e) {
						e.printStackTrace();
					}
					if(ticket>0){
						System.out.println(Thread.currentThread().getName()+"正在卖第"+ticket+"张票");
						ticket--;
					}
				}
			}
		2、测试类：
			public static void main(String[] args) {
				RunnableImpl run = new RunnableImpl();
				//使用相同的接口实现类是因为让线程使用共享的数据

				//线程类相当于窗口。Runnable接口实现类相当于票。而票是共享的数据源
				Thread t1 = new Thread(run);
				Thread t2 = new Thread(run);
				Thread t3 = new Thread(run);

				t1.start();
				t2.start();
				t3.start();
			}
	3_线程安全问题产生的原理
		1. 相同的票数,比如5这张票被卖了两回。（出现了重复的票）
			原理：这几个线程同时执行到了卖票的哪一步。而卖票->票数减少之间存在时间间隔。所以这几个线程有可能同时卖出同一张票(都是在票数减一之前失去cpu执行权)
		2. 不存在的票，比如0票与-1票，是不存在的。（出现了不存在的票）
			原理：
				1、当这些线程都是到"if判断票数是否大于0"的时候失去cpu执行权，让出执行权给其他线程(所有线程同时进入if判断语句之后)
				2、然后这些线程都是把票卖完之后，让出cpu执行权给其他线程来卖票。
					(因为所有线程都是在if语句那里开始执行，而且票数最后还减一。所以票数可能出现不存在的问题)
					
		3、注意：
			线程安全问题是不能产生的，我们可以让一个线程在访问共享数据的时候。
			无论是否失去cpu的执行权；让其他的线程只能等待，等待当前线程卖完票。其他线程才能再进行卖票
	4_解决线程安全问题_同步代码块
		1、解决线程安全问题的一种方案:使用同步代码块
			为了保证每个线程都能正常执行原子操作,Java引入了线程同步机制。有三种方式完成同步操作：
			1. 同步代码块。
			2. 同步方法。
			3. 锁机制。
			
			线程同步机制：也就是说在某个线程修改共享资源的时候，其他线程不能修改该资源，等待修改完毕同步之后，才能去抢夺CPU
				资源，完成对应的操作，保证了数据的同步性，解决了线程不安全的现象。
		2、格式(在Runnable接口的实现类的run方法中写):
			synchronized(锁对象){
				可能会出现线程安全问题的代码(访问了共享数据的代码)
			}

		3、注意:
			1.通过代码块中的锁对象,可以使用任意的对象
			2.但是必须保证多个线程使用的锁对象是同一个
			3.锁对象作用:
				把同步代码块锁住,只让一个线程在同步代码块中执行
				
				
				
		4、例子：
			private int ticket = 1;
			//锁对象。不能写在run方法中，因为要保证线程的锁对象唯一
			Object obj = new Object();
			@Override
			public void run() {
				while(true){
					//同步代码块解决线程安全问题：
					synchronized(obj){
						//为了提高线程出现问题的概率，让程序睡眠
						try {
							Thread.sleep(10);
						} catch (InterruptedException e) {
							e.printStackTrace();
						}
						if(ticket>0){
							System.out.println(Thread.currentThread().getName()+"正在卖第"+ticket+"张票");
							ticket--;
						}
					}
				}
			}
	5_同步技术的原理
		1、使用了一个锁对象。这个锁对象叫同步锁，也叫对象锁，也叫对象监视器
		2、同步代码块中的线程，没有执行完毕不会释放锁。同步代码块外的线程没有锁对象，进不去同步代码块中执行。只能等待其他线程归还锁对象
		3、同步代码块保证了只能有一个线程在同步中执行共享数据(保证了安全)
			但是频繁的判断锁、获取锁、释放锁。程序的效率会降低
	6_解决线程安全问题_同步方法
		1、解决线程安全问题的二种方案:使用同步方法
		2、使用步骤:
			1.把访问了共享数据的代码抽取出来,放到一个方法中
			2.在方法上添加synchronized修饰符

		3、格式:定义方法的格式
			修饰符 synchronized 返回值类型 方法名(参数列表){
				可能会出现线程安全问题的代码(访问了共享数据的代码)
			}
		4、定义一个同步方法，同步方法也会把方法内部的代码锁住，只让一个线程执行
			同步方法的锁对象是谁?就是实现类对象 new RunnableImpl()，也是就是this。
			
		5、例子：
			1、同步方法：
				public synchronized void payTicket(){
					//为了提高线程出现问题的概率，让程序睡眠
					try {
						Thread.sleep(10);
					} catch (InterruptedException e) {
						e.printStackTrace();
					}
					if(ticket>0){
						System.out.println(Thread.currentThread().getName()+"正在卖第"+ticket+"张票");
						ticket--;
					}
				}
			2、与同步方法类似的同步代码块：
				public /*synchronized*/ void payTicket(){
					synchronized(this){
						//为了提高线程出现问题的概率，让程序睡眠
						try {
							Thread.sleep(10);
						} catch (InterruptedException e) {
							e.printStackTrace();
						}
						if(ticket>0){
							System.out.println(Thread.currentThread().getName()+"正在卖第"+ticket+"张票");
							ticket--;
						}
					}
				}
	7_静态同步方法
		1、静态的同步方法锁对象是谁?
			不能是this,因为this是创建对象之后产生的,静态方法优先于对象
			静态方法的锁对象是本类的class属性-->class文件对象(反射)
		2、例子：
			public static /*synchronized*/ void payTicketStatic(){
				synchronized (RunnableImpl.class){
					//先判断票是否存在
					if(ticket>0){
						//提高安全问题出现的概率,让程序睡眠
						try {
							Thread.sleep(10);
						} catch (InterruptedException e) {
							e.printStackTrace();
						}
						//票存在,卖票 ticket--
						System.out.println(Thread.currentThread().getName()+"-->正在卖第"+ticket+"张票");
						ticket--;
					}
				}
			}
	8_解决线程安全问题_Lock锁
		1、解决线程安全问题的三种方案:使用Lock锁
		2、java.util.concurrent.locks.Lock接口
			Lock 实现提供了比使用 synchronized 方法和语句可获得的更广泛的锁定操作。
			Lock接口中的方法:
				1、void lock()获取锁。
				2、void unlock()  释放锁。
		3、Lock接口的实现类：java.util.concurrent.locks.ReentrantLock implements Lock接口

		4、使用步骤:
			1.在成员变量位置创建一个ReentrantLock对象
			2.在可能会出现安全问题的代码前调用Lock接口中的方法lock获取锁
			3.在可能会出现安全问题的代码后调用Lock接口中的方法unlock释放锁
		5、例子：
			private int ticket = 100;
			//1.在成员变量位置创建一个ReentrantLock对象
			Lock l = new ReentrantLock();
			@Override
			public void run() {
				while(true){
					//2.在可能会出现安全问题的代码前调用Lock接口中的方法lock获取锁
					l.lock();
					try {
						//为了提高线程出现问题的概率，让程序睡眠
						Thread.sleep(10);
						if(ticket>0){
							System.out.println(Thread.currentThread().getName()+"正在卖第"+ticket+"张票");
							ticket--;
						}
					} catch (InterruptedException e) {
						e.printStackTrace();
					}finally{
						//3.在可能会出现安全问题的代码后调用Lock接口中的方法unlock释放锁
						l.unlock();
					}
				}
			}
第4节 等待唤醒机制
	1_线程状态概述
		1、NEW:至今尚未启动的线程处于这种状态。 
		2、RUNNABLE:正在 Java 虚拟机中执行的线程处于这种状态。 
		3、BLOCKED:受阻塞并等待某个监视器锁的线程处于这种状态。 
		4、WAITING:无限期地等待另一个线程来执行某一特定操作的线程处于这种状态。 
		5、TIMED_WAITING:等待另一个线程来执行取决于指定等待时间的操作的线程处于这种状态。 
		6、TERMINATED:已退出的线程处于这种状态。
			terminated
		
		
		阻塞状态：具有cpu的执行资格，等待cpu空闲时执行
		休眠状态：放弃cpu的执行资格，cpu空闲也不执行
		
		
		
		runnable-->timed_waiting
			sleep(long)
			wait(long)
		timed_waiting-->runnable
			休眠结束,cpu空闲
		timed_waiting-->blocked
			休眠结束,cpu不空闲
			
		runnable-->waiting
			Object.wait()
		waiting-->runnable
			cpu空闲,Object.notify();
		waiting-->blocked
			cpu不空闲,Object.notify();
	2_等待唤醒案例分析
		等待唤醒案例：线程间的通信(使用同步块中的锁对象来调用wait()方法和notify()方法)
		
		消费者(顾客):顾客要求买包子,和老板说明包子的数量和种类。顾客就等着老板做包子(掉用wait()方法)Waiting状态：无限等待状态
		
			wait()		通信			notify()
		
		生产者(老板):老板开始做包子，做好包子，告诉(调用notify()方法)顾客包子做好了
	3_等待唤醒案例代码实现
		1、等待唤醒案例:线程之间的通信
			创建一个顾客线程(消费者):告知老板要的包子的种类和数量,调用wait方法,放弃cpu的执行,进入到WAITING状态(无限等待)
			创建一个老板线程(生产者):花了5秒做包子,做好包子之后,调用notify方法,唤醒顾客吃包子

		2、注意:
			1、顾客和老板线程必须使用同步代码块包裹起来,保证等待和唤醒只能有一个在执行
			2、同步使用的锁对象必须保证唯一
			3、只有锁对象才能调用wait和notify方法

		3、Obejct类中的方法
			1、void wait()
				  在其他线程调用此对象的 notify() 方法或 notifyAll() 方法前，导致当前线程等待。
			2、void notify()
				  唤醒在此对象监视器上等待的单个线程。
				  会继续执行wait方法之后的代码
				  
		4、例子：
			public static void main(String[] args) {
				//创建锁对象,保证唯一
				Object obj = new Object();
				// 创建一个顾客线程(消费者)
				new Thread(){
					@Override
					public void run() {
					   //一直等着买包子
					   while(true){
						   //保证等待和唤醒的线程只能有一个执行,需要使用同步技术
						   synchronized (obj){
							   System.out.println("告知老板要的包子的种类和数量");
							   //调用wait方法,放弃cpu的执行,进入到WAITING状态(无限等待)
							   try {
								   obj.wait();
							   } catch (InterruptedException e) {
								   e.printStackTrace();
							   }
							   //唤醒之后执行的代码
							   System.out.println("包子已经做好了,开吃!");
							   System.out.println("---------------------------------------");
						   }
					   }
					}
				}.start();

				//创建一个老板线程(生产者)
				new Thread(){
					@Override
					public void run() {
						//一直做包子
						while (true){
							//花了5秒做包子
							try {
								Thread.sleep(5000);//花5秒钟做包子
							} catch (InterruptedException e) {
								e.printStackTrace();
							}

							//保证等待和唤醒的线程只能有一个执行,需要使用同步技术
							synchronized (obj){
								System.out.println("老板5秒钟之后做好包子,告知顾客,可以吃包子了");
								//做好包子之后,调用notify方法,唤醒顾客吃包子
								obj.notify();
							}
						}
					}
				}.start();
			}
	4_Object类中wait带参方法和notifyAll方法
		1、进入到TimeWaiting(计时等待)有两种方式
			1.使用sleep(long m)方法,在毫秒值结束之后,线程睡醒进入到Runnable/Blocked状态
			2.使用wait(long m)方法,wait方法如果在毫秒值结束之后,还没有被notify唤醒,就会自动醒来,线程睡醒进入到Runnable/Blocked状态

		2、唤醒的方法:
			1、void notify() 唤醒在此对象监视器上等待的单个线程。//如果有多个等待线程,随机唤醒一个
			2、void notifyAll() 唤醒在此对象监视器上等待的所有线程。
			
			
			
	【		
		教学目标
		1、能够理解线程通信概念
		2、能够理解等待唤醒机制
		3、能够描述Java中线程池运行原理
		4、能够理解函数式编程相对于面向对象的优点
		5、能够掌握Lambda表达式的标准格式
		6、能够使用Lambda标准格式使用Runnable与Comparator接口
		7、能够掌握Lambda表达式的省略格式与规则
		8、能够使用Lambda省略格式使用Runnable与Comparator接口
		9、能够通过Lambda的标准格式使用自定义的接口（有且仅有一个抽象方法）
		10、能够通过Lambda的省略格式使用自定义的接口（有且仅有一个抽象方法）
		11、能够明确Lambda的两项使用前提
	】

	5_线程间通信
		1、概念：多个线程在处理同一个资源，但是处理的动作（线程的任务）却不相同。
			比如：线程A用来生成包子的，线程B用来吃包子的，包子可以理解为同一资源，线程A与线程B处理的动作，一个是生产，一个是消费，
			那么线程A与线程B之间就存在线程通信问题。
			
		2、为什么要处理线程间通信
			多个线程并发执行时, 在默认情况下CPU是随机切换线程的，当我们需要多个线程来共同完成一件任务，
			并且我们希望他们有规律的执行, 那么多线程之间需要一些协调通信，以此来帮我们达到多线程共同操作一份数据。
			
			
		3、如何保证线程间通信有效利用资源
			多个线程在处理同一个资源，并且任务不同时，需要线程通信来帮助解决线程之间对同一个变量的使用或操作。 
			就是多个线程在操作同一份数据时， 避免对同一共享变量的争夺。也就是我们需要通过一定的手段使各个线程能有效的利用资源。
			而这种手段即—— 等待唤醒机制
	6_等待唤醒机制概述
		1、什么是等待唤醒机制(协作机制)
			这是多个线程间的一种协作机制。谈到线程我们经常想到的是线程间的竞争（race），比如去争夺锁，但这并不是故事的全部，
			线程间也会有协作机制。就好比在公司里你和你的同事们，你们可能存在在晋升时的竞争，但更多时候你们更多是一起合作以完成某些任务。
			就是在一个线程进行了规定操作后，就进入等待状态（wait()）， 等待其他线程执行完他们的指定代码过后 再将其唤醒（notify()）;
			在有多个线程进行等待时， 如果需要，可以使用 notifyAll()来唤醒所有的等待线程。wait/notify 就是线程间的一种协作机制。
			
			
			
			等待与唤醒机制(协作机制)：线程间的通信
			重点：有效的利用资源(生产一个包子，吃一个包子，再生产一个包子，再吃一个包子...)
			
			通信：对包子的状态进行判断：
				没有包子：吃货线程唤醒包子铺线程-->吃货线程等待-->包子铺线程做包子-->做好包子-->修改包子的状态为有
				有包子：包子铺线程唤醒吃货线程-->包子铺线程等待-->吃货吃包子-->吃完包子-->修改包子的状态为没有
				...
		2、等待唤醒中的方法
			等待唤醒机制就是用于解决线程间通信的问题的，使用到的3个方法的含义如下：
				1. wait：线程不再活动，不再参与调度，进入 wait set 中，因此不会浪费 CPU 资源，也不会去竞争锁了，这时的线程状态即是 WAITING。
					它还要等着别的线程执行一个特别的动作，也即是“通知（notify）”在这个对象上等待的线程从wait set 中释放出来，重新进入到调度队列（ready queue）中
				2. notify：则选取所通知对象的 wait set 中的一个线程释放；例如，餐馆有空位置后，等候就餐最久的顾客最先入座。
				3. notifyAll：则释放所通知对象的 wait set 上的全部线程。
				
				注意：哪怕只通知了一个等待的线程，被通知线程也不能立即恢复执行，因为它当初中断的地方是在同步块内，
					而此刻它已经不持有锁，所以她需要再次尝试去获取锁（很可能面临其它线程的竞争），成功后才能在当初调用 wait 方法之后的地方恢复执行。
					即等待状态的线程使用notify唤醒后有两种可能一种是runnable状态或者是blocked状态
					
					
				总结如下：
					如果能获取锁，线程就从 WAITING 状态变成 RUNNABLE 状态；
					否则，从 wait set 出来，又进入 entry set，线程就从 WAITING 状态又变成 BLOCKED 状态
		3、调用wait和notify方法需要注意的细节
			1. wait方法与notify方法必须要由同一个锁对象调用。因为：对应的锁对象可以通过notify唤醒使用同一个锁对象调用的wait方法后的线程。
			2. wait方法与notify方法是属于Object类的方法的。因为：锁对象可以是任意对象，而任意对象的所属类都是继承了Object类的。
			3. wait方法与notify方法必须要在同步代码块或者是同步函数中使用。因为：必须要通过锁对象调用这2个方法。
	7_等待唤醒机制需求分析
		等待唤醒机制其实就是经典的“生产者与消费者”的问题。
		
		1、资源类：包子类
			设置包子的属性：皮、馅、包子的状态(true、false)
		2、生产者类(包子铺)：是一个线程类，可以继承Thread或者实现Runnable接口
			设置线程任务(run):生产包子
				对包子状态进行判断：
					true：包子铺调用wait()方法进入等待状态
					false：包子铺生产包子、修改包子的状态为true、唤醒吃货线程吃包子
		3、消费者类(吃货类)：是一个线程类，可以继承Thread或者实现Runnable接口
			设置线程任务(run):吃包子
				对包子状态进行判断：
					false:没有包子、吃货线程调用wait()方法进入等待状态
					true：吃货吃包子、修改包子状态为false、并唤醒包子铺线程生产包子
					
		4、测试类：
			包含main方法，程序执行的入口，启动程序
				1、创建包子对象
				2、创建包子线程.开启
				3、创建吃货线程.开启
			
	8_等待唤醒机制代码实现_包子类&包子铺类
		注意：
			包子铺线程和包子线程关系-->通信（互斥）
			1、必须保证同时同步技术保证两个线程只有一个在执行。
			2、锁对象必须保证唯一，可以使用包子对象作为锁对象
			3、包子铺类和吃货类就需要把包子对象作为参数传递进来
				1、需要在成员位置创建一个包子变量
				2、使用带参数的构造方法，为这个包子变量赋值
	9_等待唤醒机制代码实现_吃货类&测试类
第5节 线程池
	1_线程池的概念和原理
		1、线程池：容器-->集合(ArrayList、LinkedList<Thread>、HashSet、HashMap)
			线程池：其实就是一个容纳多个线程的容器，其中的线程可以反复使用，省去了频繁创建线程对象的操作，无需反复创建线程而消耗过多资源。
			
		2、底层原理：当程序第一次启动的时候，创建多个线程保存到一个集合中，当我们想要使用线程的时候，就可以从集合中取出来线程使用
			1、Thread t = list.remove(0)返回的是被移除的元素(线程只能被一个任务使用)
			2、Thread t = linked.removeFist()
			
			当我们使用完线程后，需要把线程归还到线程池当中
			1、list.add(t);
			2、linked.addLast(t);
			
		3、注意事项：
			1、在JDK1.5之后，JDK内置了线程池，我们可以直接使用
			2、当线程池没有已经没有空闲的线程时，任务等待执行,等待其他任务执行完毕后，归还线程到线程池。再从线程池中获取线程，自己写任务
		
		
		4、合理利用线程池能够带来三个好处：
			1. 降低资源消耗。减少了创建和销毁线程的次数，每个工作线程都可以被重复利用，可执行多个任务。
			2. 提高响应速度。当任务到达时，任务可以不需要的等到线程创建就能立即执行。
			3. 提高线程的可管理性。可以根据系统的承受能力，调整线程池中工作线线程的数目，防止因为消耗过多的内存，
				而把服务器累趴下(每个线程需要大约1MB内存，线程开的越多，消耗的内存也就越大，最后死机)。
	2_线程池的代码实现(Executors类(newFixedThreadPool()静态方法)、ExecutorService接口(submit()方法、shutdown()方法))
		1、线程池:JDK1.5之后提供的
		2、java.util.concurrent.Executors:线程池的工厂类,用来生成线程池
		3、Executors类中的静态方法:
			static ExecutorService newFixedThreadPool(int nThreads) 创建一个可重用固定线程数的线程池
			参数:
				int nThreads:创建线程池中包含的线程数量
			返回值:
				ExecutorService接口,返回的是ExecutorService接口的实现类对象,我们可以使用ExecutorService接口接收(面向接口编程)
		4、java.util.concurrent.ExecutorService:线程池接口
			用来从线程池中获取线程,调用start方法,执行线程任务
				submit(Runnable task) 提交一个 Runnable 任务用于执行
			关闭/销毁线程池的方法
				void shutdown()
		5、线程池的使用步骤:
			1.使用线程池的工厂类Executors里边提供的静态方法newFixedThreadPool生产一个指定线程数量的线程池
			2.创建一个类,实现Runnable接口,重写run方法,设置线程任务
			3.调用ExecutorService中的方法submit,传递线程任务(实现类),开启线程,执行run方法
			4.调用ExecutorService中的方法shutdown销毁线程池(不建议执行)
			
		6、注意事项：
			1、线程池会一直开启,使用完了线程,会自动把线程归还给线程池,线程可以继续使用
			2、调用ExecutorService中的方法shutdown销毁线程池(不建议执行)后，执行
				es.submit(new RunnableImpl());//抛异常,线程池都没有了,就不能获取线程了
第6节 Lambda表达式
	1_函数式编程思想概述
		1、面向对象的思想:
		​	做一件事情,找一个能解决这个事情的对象,调用对象的方法,完成事情.
		2、函数式编程思想:
		​	只要能获取到结果,谁去做的,怎么做的都不重要,重视的是结果,不重视过程
	2_冗余的Runnable代码
		对于`Runnable`的匿名内部类用法，可以分析出几点内容：
			1、Thread类需要Runnable接口作为参数，其中的抽象run方法是用来指定线程任务内容的核心；
			2、为了指定run的方法体，**不得不**需要Runnable接口的实现类；
			3、为了省去定义一个RunnableImpl实现类的麻烦，**不得不**使用匿名内部类；
			4、必须覆盖重写抽象run方法，所以方法名称、方法参数、方法返回值**不得不**再写一遍，且不能写错；
			5、而实际上，**似乎只有方法体才是关键所在**。
	3_编程思想转换&体验Lambda的更优写法
		1、借助Java 8的全新语法，上述`Runnable`接口的匿名内部类写法可以通过更简单的Lambda表达式达到等效：
			public class Demo02LambdaRunnable {
				public static void main(String[] args) {
					new Thread(() -> {System.out.println("多线程任务执行！")}).start(); // 启动线程
				}
			}
	4_Lambda标准格式
		1、匿名内部类的好处与弊端：
			一方面，匿名内部类可以帮我们省去实现类的定义；另一方面，匿名内部类的语法——确实太复杂了！
		2、Lambda省去面向对象的条条框框，格式由**3个部分**组成：
			1、一些参数
			2、一个箭头
			3、一段代码

		3、Lambda表达式的**标准格式**为：(参数类型 参数名称) -> { 代码语句 };

		4、格式说明：
			():接口中抽象方法的参数列表,没有参数,就空着;有参数就写出参数,多个参数使用逗号分隔
            ->:传递的意思,把参数传递给方法体{}
            {}:重写接口的抽象方法的方法体

	5_Lambda表达式的无参数无返回值的练习
		1、需求:
			给定一个厨子Cook接口，内含唯一的抽象方法makeFood，且无参数、无返回值。
			使用Lambda的标准格式调用invokeCook方法，打印输出“吃饭啦！”字样
			
		2、代码案例：
			//类
			public class TestCook {
				public static void main(String[] args) {
					//实现匿名内部类作为参数
					invokeCook(new Cook() {
						@Override
						public void makeFood() {
							System.out.println("吃饭了");
						}
					});

					invokeCook(()->{
						System.out.println("吃饭了");
					});
				}

				//调用接口的方法,参数是接口的实现类
				public static void invokeCook(Cook cook){
					cook.makeFood();
				}
			}
			
			//接口
			public interface Cook {
				public abstract void makeFood();
			}
	6_Lambda表达式有参数有返回值的练习
		1、需求:
			使用数组存储多个Person对象
			对数组中的Person对象使用Arrays的sort方法通过年龄进行升序排序
			//当需要对一个对象数组进行排序时，`Arrays.sort`方法需要一个`Comparator`接口实例来指定排序的规则
			
			
		2、代码案例：
			public static void main(String[] args) {
				Person[] arr = {
						new Person("aaa",30),
						new Person("bb",20),
						new Person("cc",10)
				};
				//使用匿名内部类的方式重写了Comparator接口
				/*Arrays.sort(arr, new Comparator<Person>() {
					@Override
					public int compare(Person o1, Person o2) {
						return o1.getAge()-o2.getAge();
					}
				});*/

				Arrays.sort(arr,(Person o1,Person o2)->{
					return o1.getAge()-o2.getAge();
				});


				for (Person person : arr) {
					System.out.println(person.toString());
				}
			}
	7_Lambda表达式有参数有返回值的练习(自定义接口)
		1、需求:
			给定一个计算器Calculator接口，内含抽象方法calc可以将两个int数字相加得到和值
			使用Lambda的标准格式调用invokeCalc方法，完成120和130的相加计算
			
		2、代码案例：
			public static void main(String[] args) {
				//方法的参数是一个接口，可以使用匿名内部类
				invokeCalc(12, 13, new Calculator() {
					@Override
					public int calc(int a, int b) {
						return a + b;
					}
				});

				//使用Lambda表达式简化匿名内部类的写法
				invokeCalc(120,130,(int a,int b)->{
					return a + b;
				});
			}

			public static void invokeCalc(int a,int b,Calculator calculator){
				int result = calculator.calc(a,b);
				System.out.println("结果是："+result);
			}

	8_Lambda省略格式&Lambda使用前提
		1、Lambda表达式:是可推导,可以省略
			凡是根据上下文推导出来的内容,都可以省略书写
		2、可以省略的内容:
			1.(参数列表):括号中参数列表的数据类型,可以省略不写
			2.(参数列表):括号中的参数如果只有一个,那么类型和()都可以省略
			3.{一些代码}:如果{}中的代码只有一行,无论是否有返回值,都可以省略({},return,分号)
				注意:要省略{},return,分号必须一起省略
				
				
		3、Lambda的语法非常简洁，完全没有面向对象复杂的束缚。但是使用时有几个问题需要特别注意：
			1. 使用Lambda必须具有接口，且要求"接口中有且仅有一个抽象方法"。
			   无论是JDK内置的`Runnable`、`Comparator`接口还是自定义的接口，只有当接口中的抽象方法存在且唯一时，才可以使用Lambda。
			2. 使用Lambda必须具有**上下文推断**。
			   也就是方法的参数或局部变量类型必须为Lambda对应的接口类型，才能使用Lambda作为该接口的实例。
			3、有且仅有一个抽象方法的接口，称为“**函数式接口**”。
