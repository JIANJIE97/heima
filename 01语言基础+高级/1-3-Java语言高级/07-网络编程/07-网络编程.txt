主要内容

1、软件架构CS／BS
2、网络通信三要素
3、TCP通信
4、Socket套接字
5、ServerSocket


教学目标

1、能够辨别UDP和TCP协议特点
2、能够说出TCP协议下两个常用类名称
3、能够编写TCP协议下字符串数据传输程序
4、能够理解TCP协议下文件上传案例
5、能够理解TCP协议下案例2


第1节 网络通信概述
	1、软件结构
		1、C/S结构：全称为Client/Server结构，是指客户端和服务器结构。常见程序有ＱＱ、迅雷等软件。
		2、B/S结构 ：全称为Browser/Server结构，是指浏览器和服务器结构。常见浏览器有谷歌、火狐等。
		两种架构各有优势，但是无论哪种架构，都离不开网络的支持。**网络编程**，就是在一定的协议下，实现两台计算机的通信的程序。
	2、网络通信协议
		1、网络通信协议：通过计算机网络可以使多台计算机实现连接，位于同一个网络中的计算机在进行连接和通信时需要遵守一定的规则，
			这就好比在道路中行驶的汽车一定要遵守交通规则一样。在计算机网络中，这些连接和通信的规则被称为网络通信协议，
			它对数据的传输格式、传输速率、传输步骤等做了统一规定，通信双方必须同时遵守才能完成数据交换。

		2、TCP/IP协议：传输控制协议/因特网互联协议( Transmission Control Protocol/Internet Protocol)，是Internet最基本、最广泛的协议。
			它定义了计算机如何连入因特网，以及数据如何在它们之间传输的标准。它的内部包含一系列的用于处理数据通信的协议，并采用了4层的分层模型，
			每一层都呼叫它的下一层所提供的协议来完成自己的需求。


		3、TCP/IP协议中的四层分别是应用层、传输层、网络层和链路层，每层分别负责不同的通信功能。
			1、链路层(物理层)：链路层是用于定义物理传输通道，通常是对某些网络连接设备的驱动协议，例如针对光纤、网线提供的驱动。
			2、网络层：网络层是整个TCP/IP协议的核心，它主要用于将传输的数据进行分组，将分组数据发送到目标计算机或者网络。
			3、运输层：主要使网络程序进行通信，在进行网络通信时，可以采用TCP协议，也可以采用UDP协议。
			4、应用层：主要负责应用程序的协议，例如HTTP协议、FTP协议等。

	3、网络通信协议分类
		1、通信的协议还是比较复杂的，java.net 包中包含的类和接口，它们提供低层次的通信细节。
			我们可以直接使用这些类和接口，来专注于网络程序开发，而不用考虑通信的细节。
		2、java.net 包中提供了两种常见的网络协议的支持：
			1、UDP：用户数据报协议(User Datagram Protocol)。UDP是"无连接"通信协议，即在数据传输时，数据的发送端和接收端不建立逻辑连接。
				1、概述：简单来说，当一台计算机向另外一台计算机发送数据时，发送端不会确认接收端是否存在，就会发出数据，同样接收端在收到数据时，
					也不会向发送端反馈是否收到数据。由于使用UDP协议消耗资源小，通信效率高，所以通常都会用于音频、视频和普通数据的传输例如视频会议都使用UDP协议，
					因为这种情况即使偶尔丢失一两个数据包，也不会对接收结果产生太大影响。但是在使用UDP协议传送数据时，由于UDP的面向无连接性，
					不能保证数据的完整性，因此在传输重要数据时不建议使用UDP协议。
				2、特点:数据被限制在64kb以内，超出这个范围就不能发送了。
				3、数据报(Datagram):网络传输的基本单位 
			2、TCP：传输控制协议 (Transmission Control Protocol)。TCP协议是**面向连接**的通信协议，即传输数据之前，
				在发送端和接收端建立逻辑连接，然后再传输数据，它提供了两台计算机之间可靠无差错的数据传输。

				1、在TCP连接中必须要明确客户端与服务器端，由客户端向服务端发出连接请求，每次连接的创建都需要经过“三次握手”。
				  三次握手：TCP协议中，在发送数据的准备阶段，客户端与服务器之间的三次交互，以保证连接的可靠。
					1、第一次握手，客户端向服务器端发出连接请求，等待服务器确认。
					2、第二次握手，服务器端向客户端回送一个响应，通知客户端收到了连接请求。
					3、第三次握手，客户端再次向服务器端发送确认信息，确认连接。整个交互过程如下图所示。
			​    2、完成三次握手，连接建立后，客户端和服务器就可以开始进行数据传输了。由于这种面向连接的特性，
					TCP协议可以保证传输数据的安全，所以应用十分广泛，例如下载文件、浏览网页等。
	4、IP地址
		1、网络编程三要素:协议、IP地址、端口号
		2、协议:计算机网络通信必须遵守的规则
		3、IP地址：
			1、概述：指互联网协议地址（Internet Protocol Address），俗称IP。IP地址用来给一个网络中的计算机设备做唯一的编号。
				假如我们把“个人电脑”比作“一台电话”的话，那么“IP地址”就相当于“电话号码”。
			2、IP地址分类：
				1、IPv4：是一个32位的二进制数，通常被分为4个字节，表示成`a.b.c.d` 的形式，例如`192.168.65.100` 。
					其中a、b、c、d都是0~255之间的十进制整数，那么最多可以表示42亿个。
				2、IPv6：由于互联网的蓬勃发展，IP地址的需求量愈来愈大，但是网络地址资源有限，使得IP的分配越发紧张。
					为了扩大地址空间，拟通过IPv6重新定义地址空间，采用128位地址长度，每16个字节一组，分成8组十六进制数，
					表示成`ABCD:EF01:2345:6789:ABCD:EF01:2345:6789`，号称可以为全世界的每一粒沙子编上一个网址，这样就解决了网络地址资源数量不够的问题。
			3、常用命令
				1、查看本机IP地址，在控制台输入：ipconfig
				2、检查网络是否连通，在控制台输入：
					ping 空格 IP地址
					ping 220.181.57.216
				3、特殊的IP地址：
					本机IP地址：127.0.0.1
					本机域名：localhost 
	5、端口号
		1、网络的通信，本质上是两个进程（应用程序）的通信。每台计算机都有很多的进程，那么在网络通信时，如何区分这些进程呢？
			如果说**IP地址**可以唯一标识网络中的设备，那么**端口号**就可以唯一标识设备中的进程（应用程序）了。
		2、端口号：用两个字节表示的整数，它的取值范围是0~65535。其中，0~1023之间的端口号用于一些知名的网络服务和应用，
			普通的应用程序需要使用1024以上的端口号。如果端口号被另外一个服务或应用所占用，会导致当前程序启动失败。
		3、利用`协议`+`IP地址`+`端口号` 三元组合，就可以标识网络中的进程了，那么进程间的通信就可以利用这个标识与其它进程进行交互。
		4、常用的端口号：
			1、网络端口：80端口
			2、数据库端口：
				mysql：3306端口
				oracle:1521端口
			3、Tomcat:8080端口
第2节 TCP协议
	1、TCP通信的概述(上)
		1、概述：
			TCP通信能实现两台计算机之间的数据交互，通信的两端，要严格区分为客户端（Client）与服务端（Server）。
			TCP:面向连接的通信，客户端和服务端必须经过三次握手，建立逻辑连接，才能通信(安全)

		2、两端通信时步骤：
			1. 服务端程序，需要事先启动，等待客户端的连接。
			2. 客户端主动连接服务器端，连接成功才能通信。服务端不可以主动连接客户端。
			3、客户端和服务端建立了一个逻辑连接，而这个连接中包含一个对象，而这个对象就是IO对象。
				客户端和服务端就可以使用IO对象进行通信。因为通信的数据不仅仅是字符，所以这个IO对象是字节流对象
			注意：客户端和服务端进行一次数据交换，需要4个IO流对象

		3、在Java中，提供了两个类用于实现TCP通信程序：
			1. 客户端：java.net.Socket 类表示。创建`Socket`对象，向服务端发出连接请求，服务端响应请求，两者建立连接开始通信。
			2. 服务端：java.net.ServerSocket 类表示。创建`ServerSocket`对象，相当于开启一个服务，并等待客户端的连接。

		4、Socket类  
			`Socket` 类：该类实现客户端套接字，套接字指的是两台设备之间通讯的端点。
	2、TCP通信的概述(下)
		1、服务端必须明确两件事：
			1、多个客户端同时和服务器进行交互，服务器必须明确和那个客户端进行交互。
				在服务端有一个方法，叫做accept()。返回一个请求的客户端对象
			2、多个客户端同时和服务端进行交互，就需要使用多个IO流对象
				1、服务端是没有IO流的，服务器可以获取到请求的客户端对象Socket
				2、使用客户端Socket中提供的IO流和客户端进行通信。例如：
					1、服务器使用客户端的字节输入流读取客户端发送的数据
					2、服务器使用客户端的字节输出流给客户端回写数据
				3、简单记：服务器使用客户端的流和客户端通信
	3、TCP通信的客户端代码实现
		1、TCP通信的客户端:向服务器发送连接请求,给服务器发送数据,读取服务器回写的数据
		2、表示客户端的类:
			1、java.net.Socket:此类实现客户端套接字（也可以就叫“套接字”）。套接字是两台机器间通信的端点。
			2、套接字:包含了IP地址和端口号的网络单位

		3、构造方法:
			1、Socket(String host, int port) 创建一个流套接字并将其连接到指定主机上的指定端口号。
			2、参数:
				1、String host:服务器主机的名称/服务器的IP地址
				2、int port:服务器的端口号

		4、成员方法:
			1、OutputStream getOutputStream() 返回此套接字的输出流。
			2、InputStream getInputStream() 返回此套接字的输入流。
			3、void close() 关闭此套接字。

		5、实现步骤:
			1.创建一个客户端对象Socket,构造方法绑定服务器的IP地址和端口号
			2.使用Socket对象中的方法getOutputStream()获取网络字节输出流OutputStream对象
			3.使用网络字节输出流OutputStream对象中的方法write,给服务器发送数据
			4.使用Socket对象中的方法getInputStream()获取网络字节输入流InputStream对象
			5.使用网络字节输入流InputStream对象中的方法read,读取服务器回写的数据
			6.释放资源(Socket)
		 6、注意:
			1.客户端和服务器端进行交互,必须使用Socket中提供的网络流,不能使用自己创建的流对象
		***	2.当我们创建客户端对象Socket的时候,就会去请求服务器和服务器经过3次握手建立连接通路
				1、这时如果服务器没有启动,那么就会抛出异常ConnectException: Connection refused: connect
				2、如果服务器已经启动,那么就可以进行交互了
	4、TCP通信的服务器端代码实现
		1、TCP通信的服务器端:接收客户端的请求,读取客户端发送的数据,给客户端回写数据
		2、表示服务器的类:
			java.net.ServerSocket:此类实现服务器套接字。

		3、构造方法:
			ServerSocket(int port) 创建绑定到特定端口的服务器套接字。

		4、服务器端必须明确一件事情,必须的知道是哪个客户端请求的服务器
			所以可以使用accept方法获取到请求的客户端对象Socket
		5、成员方法:
			Socket accept() 侦听并接受到此套接字的连接。返回值是客户端请求的Socket

		6、服务器的实现步骤:
			1.创建服务器ServerSocket对象和系统要指定的端口号
			2.使用ServerSocket对象中的方法accept,获取到请求的客户端对象Socket
			3.使用Socket对象中的方法getInputStream()获取网络字节输入流InputStream对象
			4.使用网络字节输入流InputStream对象中的方法read,读取客户端发送的数据
			5.使用Socket对象中的方法getOutputStream()获取网络字节输出流OutputStream对象
			6.使用网络字节输出流OutputStream对象中的方法write,给客户端回写数据
			7.释放资源(Socket,ServerSocket)
	
第3节 综合案例_文件上传
	1、综合案例_文件上传的原理
		1、TCP通信的文件上传案例原理：
			客户端读取本地的文件,把文件上传到服务器，服务器把上传的文件保存到服务器的硬盘上
		2、实现步骤：
			1、客户端使用"本地的字节输入流"，读取本地的文件
			2、客户端使用"网络的字节输出流"，把读取到的文件上传到服务器
			3、服务器使用"网络的字节输入流"，读取客户端上传的文件
			4、服务器使用"本地的字节输出流"，把读取到的文件，保存到服务器的硬盘上
			5、服务器使用"网络的字节输出流"，给客户端回写一个"上传成功"
			6、客户端使用"网络的字节输入流"，读取服务器回写的数据
			7、释放资源
		3、注意：
			1、客户端和服务器和本地硬盘进行读写，需要使用自己创建的字节流对象(本地流)
			2、客户端和服务器之间进行读写，必须使用Socket中提供的字节流对象(网络流)
			
		4、文件上传的原理就是文件的复制
			明确：
				1、数据源
				2、数据目的地

	2、综合案例_文件上传案例的客户端
		1、文件上传案例的客户端:读取本地文件,上传到服务器,读取服务器回写的数据
		2、明确:
			数据源:c:\\1.jpg
			目的地:服务器
		3、实现步骤:
			1.创建一个本地字节输入流FileInputStream对象,构造方法中绑定要读取的数据源
			2.创建一个客户端Socket对象,构造方法中绑定服务器的IP地址和端口号
			3.使用Socket中的方法getOutputStream,获取网络字节输出流OutputStream对象
			4.使用本地字节输入流FileInputStream对象中的方法read,读取本地文件
			5.使用网络字节输出流OutputStream对象中的方法write,把读取到的文件上传到服务器
			6.使用Socket中的方法getInputStream,获取网络字节输入流InputStream对象
			7.使用网络字节输入流InputStream对象中的方法read读取服务回写的数据
			8.释放资源(FileInputStream,Socket)
	3、综合案例_文件上传案例的服务器端
		1、文件上传案例服务器端:读取客户端上传的文件,保存到服务器的硬盘,给客户端回写"上传成功"

		2、明确:
			1、数据源:客户端上传的文件
			2、目的地:服务器的硬盘 d:\\upload\\1.jpg

		3、实现步骤:
			1.创建一个服务器ServerSocket对象,和系统要指定的端口号
			2.使用ServerSocket对象中的方法accept,获取到请求的客户端Socket对象
			3.使用Socket对象中的方法getInputStream,获取到网络字节输入流InputStream对象
			4.判断d:\\upload文件夹是否存在,不存在则创建
			5.创建一个本地字节输出流FileOutputStream对象,构造方法中绑定要输出的目的地
			6.使用网络字节输入流InputStream对象中的方法read,读取客户端上传的文件
			7.使用本地字节输出流FileOutputStream对象中的方法write,把读取到的文件保存到服务器的硬盘上
			8.使用Socket对象中的方法getOutputStream,获取到网络字节输出流OutputStream对象
			9.使用网络字节输出流OutputStream对象中的方法write,给客户端回写"上传成功"
			10.释放资源(FileOutputStream,Socket,ServerSocket)
	4、综合案例_文件上传案例阻塞问题
		1、出现阻塞的原因：
			1、本地输入流读取的结束标记不会写入给服务器
			2、服务端的网络的字节输入流永远不会读取到结束标记。所以服务端中的while进入死循环
			3、客户端的网络的字节输入流读取不到服务器回写的数据，进入到阻塞状态
		
		2、解决:上传完文件,给网络的字节输出流后写一个结束标记
            1、void shutdownOutput() 禁用此套接字的输出流。
            2、对于 TCP 套接字，任何以前写入的数据都将被发送，并且后跟 TCP 的正常连接终止序列。
			
			
			在客户端上传完文件(一般在write()方法后)，使用socket.shutdownOutput()方法。把以前写入的数据都将被发送。并加上结束标记
	5、综合案例_文件上传案例优化(文件命名&循环接收&多线程提高效率)
		1、代码重构
			1、文件名称命名(每次上传的文件名与时间关联)
				1、自定义一个文件的命名规则:防止同名的文件被覆盖
                2、规则:域名+毫秒值+随机数
				3、在服务端的写入服务器硬盘文件的那里重构，即在创建本地的字节输出流时作为构造方法的参数传进去
					FileOutputStream fos = new FileOutputStream(file+"\\"+fileName);
			2、死循环接收客户端的请求(服务器使用一次后不关闭)
				1、让服务器一直处于监听状态(死循环accept方法)有一个客户端上传文件,就保存一个文件
				2、在ServerSocket创建的后使用while循环包裹着所有代码
					while(true){
						//注意：ServerSocket不能释放资源。不管是在while循环里面还是外面
					}
			3、使用多线程提高效率(服务端，在接收大文件时，可能耗费几秒钟的时间，此时不能接收其他用户上传，所以，使用多线程技术优化)
				1、使用多线程技术,提高程序的效率
                2、有一个客户端上传文件,就开启一个线程,完成文件的上传				
				3、在死循环中的accept()方法后的所有代码,作为多线程的任务(即服务端每接收到一个请求就开启多线程)
					多线程就是多个线程之间快速切换。尽量提高cpu的使用率
					
					
			4、使用字节缓冲输入流和字节缓冲输出流提高传输效率。(大幅度提高效率)
				1、因为不管本地字节流还是网络字节流最后得到的是一个字节流,所以可以使用缓冲字节流可以提高传输效率。
			***	2、注意点，在关闭缓冲字节流的时候不太理解关闭顺序。会抛出异常
				
				
				
				
		2、使用多线程之前：
			1、客户端2(大文件)
				开始：1569668689827
				上传成功
				结束：1569668694182
				用时:4355毫秒
			2、客户端(小文件)
				开始：1569668692599
				上传成功
				结束：1569668694331
				用时:1732毫秒
				
		3、使用多线程之后：
			1、客户端2(大文件)
				开始：1569669746205
				上传成功
				结束：1569669752287
				用时:6082毫秒
			2、客户端(小文件)
				开始：1569669750486
				上传成功
				结束：1569669750970
				用时:484毫秒
第4节 模拟BS服务器案例
	1、模拟BS服务器分析
		1、客户端是浏览器，在搜索栏里输入http://127.0.0.1:8080/模块名(Demo0927)/web(模块下的文件下)/index.html。访问服务器
			http://127.0.0.1:8080/Demo0927/web/index.html
		2、创建服务器ServerSocket并获取网络的字节输入流来读取客户端的发来的请求信息
		3、服务器需要给客户端回写一个信息，回写一个html页面(文件)
			1、我们需要读取index.hrml文件，就必须知道这个文件的地址(这个文件的地址在客户端发来的请求信息中)
			2、地址信息在请求信息的第一行(使用缓冲字符输入流的readLine()方法读取第一行信息)
				注意：缓冲字符输入流的构造函数的参数是字符输入流。如果只有字节输入流的话，可以使用转换流作为参数InputStreamReader
				String s = new BufferedReader(new InputStreamReader(字节输入流is)).readLine();
				
			3、可以使用String的split(" ")方法切割字符串。获取中间的部分：
				String[] arr = s.split(" ");
				arr[1]
			4、使用String的substring(1),获取html文件的路径
			
		4、服务器创建一个本地的字节输入流，根据获取到的路径读取html文件
		5、回写html文件之前首先先回写三个固定的语句：
			//1、写入HTTP协议响应头,固定写法：
			out.write("HTTP/1.1 200 OK\r\n".getBytes());
			//2、
			out.write("Content-Type:text/html\r\n".getBytes());
			//3、必须写入空行,否则浏览器不解析
			out.write("\r\n".getBytes());
		6、服务器使用网络字节输入流把读取到的文件，使用网络字节输出流写到客户端（浏览器）显示
	2、模拟BS服务器代码实现
		1、注意事项：
			浏览器解析服务器回写的html页面,页面中如果有图片,那么浏览器就会单独的开启一个线程,读取服务器的图片
            我们就得让服务器一直处于监听状态,客户端请求一次,服务器就回写一次(即使用while死循环一直监听,还有使用多线程)



