第1节 继承
	1、继承的概述
		1、面向对象的三大特征：封装性、继承性、多态性
			注意：继承是多态的前提，如果没有继承，就没有多态
	***	2、继承主要解决的问题就是：共性抽取
		3、继承关系中的特点：
			1、子类可以拥有父类的"内容"
			2、子类还可以拥有自己专有的内容
			
		4、继承中的专有名词
			1、父类（推荐），也可以叫做基类、超类
			2、子类（推荐），也可以叫派生类
	2、继承的格式
		1、在继承的关系中"子类就是一个父类"。也就是说，子类可以被当做父类看待。
			例如：父类是员工，子类是讲师，那么"讲师就是一个员工"。关系："is-a".
		2、定义父类的格式与普通类的格式一模一样
		3、定义子类的格式：
			public class 子类名称 extends 父类名称{}
	3、继承中成员变量的访问特点
		1、父类对象只能使用父类的东西，没有任何子类的内容
		2、子类对象既可以调用父类的内容，也可以调用子类自身的内容
		3、在父子类继承关系当中，如果成员变量重名，则创建子类对象时，访问方式有2种
			1、直接通过子类对象访问成员变量
				规则：等号左边是谁（就是创建对象时赋值号的左边），就优先用谁，没有就向上找。如果还是没找到就是编译报错
			2、间接通过成员方法访问成员变量
				规则：该方法属于谁（就是创建该成员方法是谁的），就优先用谁，没有就向上找。如果还是没找到就是编译报错
	4、区分子类方法中重名的三种情况
		1、局部变量				直接写成员变量名
		2、本类中的成员变量		this.成员变量名
		3、父类中的成员变量		super.成员变量名
	5、继承中成员方法的访问特点
		1、在父子类的继承关系当中，创建子类对象，访问成员方法的规则：
			规则：创建的对象是谁（new的是谁，就是谁），就优先用谁，如果没有则向上找。
		2、注意事项：无论是成员方法还是成员变量，如果没有找到都是向上找父类，绝对不会向下找子类的
	6、继承中方法的覆盖重写_概念与特点
		1、重写（Override）
			概念：在继承关系当中，方法的名称一样，参数列表也一样
		2、重写与重载的区别：
			重写（Override）：方法的名称一样，参数列表【也一样】。	覆盖、覆写
			重载（Overload）：方法的名称一样，参数列表【不一样】
		3、方法的覆盖重写的特点：创建的是子类对象，则优先使用子类方法
		4、使用场景：父类的方法不满足子类的要求
	7、继承中方法的覆盖重写_注意事项
		1、必须保证父子类之间方法名称的相同，参数列表相同
			@Override	写在方法前面，用来检测是否是有效的正确覆盖重写
			这个注解就算不写，只要满足要求，也是正确的方法覆盖重写。注解是一种查看对应功能是否成功的机制
		2、父类方法的返回值范围必须【大于等于】子类方法的返回值
			拓展：java.lang.Object类是所有类的公共最高父类（祖宗类），java.lang.String就是Object的子类
		3、父类方法的权限修饰符必须【小于等于】子类方法的权限		//重写后的权限规则是放松
			拓展：public	>	protected	>	默认不写	>private	
		4、父类的private方法不能重写
		5、父类抛出的异常必须【大于等于】子类抛出的异常
		6、父类的final方法不能重写
	8、继承中方法的覆盖重写_应用场景
		1、父类的方法不满足子类的要求，在原来的基础上覆盖重写，原来的方法尽量不要修改，应该添加新内容
		
		设计原则：对于已经投入使用的类，尽量不要进行修改，推荐定义一个新的类，来重复利用其中的共性内容，并且添加改动新内容
	9、继承中构造方法的访问特点
		1、子类构造方法当中有一个默认的"super()"调用，所以一定是先调用的父类构造，后执行的子类构造
		2、子类构造可以通过super关键字来调用父类重载构造方法（即super()可以重载）
		3、super的父类构造调用，必须是子类构造方法的第一个语句。一个子类构造只能调用一次super()
			总结：子类必须调用父类的构造方法，不写就赠送super();写了则用写的指定super(),super()只能有一个，还必须是第一个
	10、super关键字的三种用法
		1、在子类的成员方法中，访问父类的成员变量。
		2、在子类的成员方法中，访问父类的成员方法
		3、在子类的构造方法中，方法父类的构造方法
	11、this关键字的三种用法
		1、super关键字用来访问父类内容，而this关键字用来访问本类内容。用法也有三种
			1、在本类的成员方法中，访问本类的成员变量（起到成员变量与局部变量区分的作用）
			2、在本类的成员方法中，访问本类的另一个成员方法
			3、在本类的构造方法中，访问另一个构造方法;		this();
			在第三种用法中要注意：
				1、this(...)调用也必须是构造方法中的第一个语句，唯一一个
				2、super和this两种构造调用，不能同时使用
	12、super与this关键字图解
		1、在加载字节码文件时，方法区中子类的字节码文件中包含有父类的标志
		2、在创建子类的对象时，在堆中先创建一个子类的内存区域，其中先创建父类内容，再创建子类内容。
	13、Java继承的三个特点
		1、Java语言是单继承的
			一个类的直接父类只能有唯一一个
		2、Java语言可以有多级继承
			当前类可以有一个父类，父类还可以有一个父类。注意目前最高的父类叫做：java.lang.Object
		3、Java语言中父类可以有多个子类
			子一个子类的直接父类是唯一的，但是一个父类可以拥有多个子类。可以拥有很多个兄弟姐妹
第2节 抽象类
	1、抽象的概念
		如果父类当中的方法不确定如何进行{}方法体的实现，那么这应该就是一个抽象方法
	2、抽象方法和抽象类的格式
		1、抽象方法：就是加上abstract关键字，然后去掉大括号，直接分号结束。
		2、抽象类：抽象方法所在的类，必须是抽象类才行。在class之前写上abstract即可
	3、抽象方法和抽象类的使用
		1、不能直接创建new抽象类对象
		2、必须使用一个子类继承抽象父类
		3、子类必须覆盖重写抽象父类当中的所有抽象方法
			覆盖重写：：子类去掉抽象方法的abstract关键字，然后补上方法体大括号
		4、创建子类对象进行使用
	4、抽象方法和抽象类的注意事项
		1、抽象类不能创建对象（否则编译报错），只能创建其非抽象子类的对象
		2、抽象类中可以有构造方法，是供子类创建对象对象时，初始化父类成员使用的（因为子类的构造方法中有默认的super(),需要访问父类构造方法）
		3、抽象类中，不一定包含抽象方法。但是有抽象方法的一定是抽象类
			理解：未包含抽象方法的抽象类，目的就是不想让调用者创建该类对象。通常用于某些特殊的类架构设计（设计模式中的适配器模式）
		4、抽象类的子类必须重写抽象父类中所有的抽象方法（否则编译报错），除非这个类是抽象类。
	5、发红包案例_分析
		1、分成三个类
			1、用户类（父类）
				姓名、余额成员变量
			2、群主类（子类）
				发红包成员方法
			3、普通成员类（子类）
				收红包成员方法
		2、发红包的逻辑三要素
			1、返回值类型：ArrayList<Integer>
			2、方法名：send
			3、参数列表:
				1、总共发多少钱：		int totalMoney
				2、分成多少份：			int count
		3、收红包的逻辑三要素
			1、返回值类型：void
			2、方法名：receive
			3、参数列表:
				1、红包集合：ArrayList<Integer>
	6、发红包案例_实现
		
第3节 接口
	01_接口概述与生活举例
		1、比如笔记本电脑上USB接口
		2、电源插座中的电源接口
		
		接口就是一种"公共的规范标准"，只要符合规范标准，就可以大家通用
	02_接口的定义基本格式
		1、接口就是多个类的公共规范
		2、接口是一种引用数据类型，最重要的内容就是其中的“抽象方法”。
		3、定义接口的格式
			public interface 接口名称{
				//接口内容
			}
			备注：换成了关键字interface之后，编译生成的字节码文件仍然是：.java->.class
		4、接口的组成部分
			1、Java 7,那么接口中包含的内容有：
				1、常量
				2、抽象方法
			2、Java 8,那么接口中包含的内容有：
				3、默认方法
				4、静态方法
			3、Java 9,那么接口中包含的内容有：
				5、私有方法
	03_接口的抽象方法定义
		1、在任何版本的Java中，接口都能定义抽象方法
		2、格式：
			public abstract 返回值类型 方法名称(参数列表);
		3、注意事项：
			1、接口当中的抽象方法，修饰符必须是两个固定的关键字:public abstract
			2、这两个关键字修饰符，可以选择性忽略。（今天刚学，不推荐）
				public abstract void method();//这是一个抽象方法
				abstract void method();//这是一个抽象方法
				public void method();//这是一个抽象方法
				void method();//这是一个抽象方法
			3、方法的三要素，可以随意定义
	04_接口的抽象方法使用
		1、接口使用步骤：
			1、接口不能直接使用，必须要有一个"实现类"来实现"接口"该接口;
				格式：
					public class 实现类名称 implements 接口名称{}
			2、接口的实现类必须覆盖重写（实现）接口中的抽象方法
				实现：去掉abstract关键字，加上方法体大括号
			3、创建实现类的对象，进行使用
			4、注意事项：
				如果实现类并没有覆盖重写接口中的所有抽象方法，那么这个实现类自己就必须是抽象类
	05_接口的默认方法定义
		1、从Java8开始，接口里允许定义默认方法
		2、格式：
			public default 返回值类型 方法名称（参数列表）{
				方法体
			}
		3、注意事项：接口当中的默认方法，可以解决接口升级的问题（即如果想在接口中再添加一个抽象方法造成的影响）。
	06_接口的默认方法使用
		1、接口的默认方法，可以通过接口实现类对象，直接调用
			调用默认方法，如果实现类当中没有，会向上找接口
		2、接口的默认方法，也可以被接口实现类进行覆盖重写
		3、使用场景：
			1、接口升级的问题
			2、学习lambda表达式和函数式编程的时候，接口的默认方法可以拼接函数模型
	07_接口的静态方法定义
		1、从Java8开始，接口里允许定义静态方法
		2、格式：
			public static 返回值类型 方法名称（参数列表）{
				方法体
			}
		3、提示：就是将abstract和default换成static即可，带上方法体
	08_接口的静态方法使用
		1、正确的使用方式：通过接口名称,直接调用其中的静态方法。
			格式：接口名称.静态方法名(参数)
		2、注意事项：不能通过接口实现类的对象调用接口当中的静态方法。原因是类可以实现多个接口，其中的静态方法可能会发生冲突。再说静态也不跟对象有关系。
	09_接口的私有方法定义
		1、问题描述：我们需要抽取一个共有方法，用来解决两个默认方法之间重复代码的问题
			但是这个共有方法不应该让实现类使用，应该私有化。
		2、解决方案：
			1、从Java9开始，接口当中允许定义私有方法
				1、普通私有方法，解决多个默认方法之间重复代码问题
					格式：private 返回值类型 方法名称(参数列表){
						方法体
					}
				2、静态私有方法，解决多个静态方法之间重复代码问题
					格式：private static 返回值类型 方法名称(参数列表){
						方法体
					}
	10_接口的私有方法使用
		注意事项：在实现类中，可以在方法中直接调用接口中的public方法，不需要对象，直接写方法名就可以调用。但是记住这只能在实现类中这样做
		解决方法：直接给接口中的方法改为私有方法就可以了。这样私有方法只能在接口中直接调用。其他类无法调用
	11_接口的常量定义和使用
		1、接口当中也可以定义"成员变量"，但是必须使用public static final 这三个关键字修饰。
			从效果上看，这其实就是接口的【常量】
			格式：public static final 数据类型 数据名称 = 数据值;
			备注：一旦使用final关键字进行修饰，说明不可改变
		2、注意事项：
			1、接口当中的常量，可以省略public static final ，注意，不写默认照样也是这样（不推荐省略）
			2、接口当中的常量，必须进行赋值，不能不赋值
			3、接口中的常量的名称，使用完全大写的字母，用下划线分隔。（推荐命名规则）
		3、使用：直接使用接口名称.常量名
	12_接口的内容小结
		在Java9+版本中，接口的内容可以有5点：
			1、成员变量其实是常量，格式：
				[public] [static] [final] 数据类型 常量名称 = 数据值;
				注意：
					1、常量必须进行赋值，而且一旦赋值不能改变
					2、常量名称完全大写，用下划线进行分隔
			2、接口中最重要的是抽象方法，格式：
				[public] [abstract] 返回值类型 方法名(参数列表);
				注意：实现类必须覆盖重写接口所有的抽象方法，除非实现类是抽象类。
			3、从Java8开始，接口里允许定义默认方法，格式：
				[public] default 返回值类型 方法名(参数列表){方法体}
				注意：默认方法也可以被覆盖重写
			4、从Java8开始，接口里允许定义静态方法，格式：
				[public] static 返回值类型 方法名(参数列表){方法体}
				注意：应该通过接口名称进行调用，不能通过实现类对象调用接口静态方法
			5、从Java9开始，接口里允许定义私有方法，格式：
				普通私有方法:private 返回值类型 方法名(参数列表){方法体}
				静态私有方法:private static 返回值类型 方法名(参数列表){方法体}
				注意：private的方法只有接口自己才能调用，不能被实现类或别人调用
	13_继承父类并实现多个接口
		1、接口使用过程中的注意事项和重要特点
			1、接口是没有静态代码块或者构造方法的。
			2、一个类的直接父类是唯一的，但是一个类可以同时实现多个接口
				格式：
				public class 类名 implements 接口1,接口2{
					//覆盖重写所有抽象方法
				}
			3、如果实现类没有覆盖重写所有接口中的所有抽象方法，那么实现类就必须是一个抽象类
			4、如果实现类所实现的多个接口中，存在重复的抽象方法，那么只需要覆盖重写一次即可。（即实现类只需覆盖重写一次接口中同名的方法）
			5、如果实现类所实现的多个接口中，存在重复的默认方法，那么实现类必须要对冲突的默认方法进行覆盖重写
		***	6、如果实现类的直接父类中的方法，和接口中的默认方法产生了冲突，优先使用父类当中的方法。（在Java当中继承的优先级是高于接口的实现的）
	14_接口之间的多继承
		1、接口与类之间的关系：
			1、类与类之间是单继承的。直接父类只有一个
			2、类与接口之间是多实现的。一个类可以实现多个接口。
			3、接口与接口之间是多继承的
		2、注意事项：
			1、多个父接口当中的抽象方法如果重复，没有关系。因为实现类中还是要实现的
			2、多个父接口当中的默认犯法如果重复，那么子接口就必须进行默认方法的覆盖重写。【重写时default不能省略】
第4节 多态
	15_多态的概述
		1、面向对象三大特征：封装性、继承性、多态性。
			extends继承或者implements实现，是多态的前提
		2、举例：学生类继承人类。创建一个对象叫做小明
			解析：对象小明是一个学生，但同时也是一个人类（这个对象既有学生形态，也有人类形态）
		***	一个对象拥有多种形态，这就是对象的多态性。
	16_多态的格式与使用
		1、代码中体现多态性其实就是一句话：父类引用指向子类对象（左侧父类的引用，指向了右侧子类的对象）
			格式1：父类名称 对象名 = new 子类名称();
			格式2：接口名称 对象名 = new 实现类名称();
		2、对象调用父类与子类同名的方法时。看new的是哪一个类就优先调用哪个方法。如果没找到，就向父类寻找
	17_多态中成员变量的使用特点
		1、访问成员变量的两种方式
			1、直接通过对象名称访问成员变量：看等号左边是谁，则对象就是谁的，左边的类中没有该成员变量，就向上找。不能向下找
			2、间接通过成员方法访问成员变量：看该方法是属于谁的（new的是谁就属于谁），则对象就是谁的。没有就向上找。不能向下找
	18_多态中成员方法的使用特点
		1、在多态代码当中，成员方法的访问规则是：看new的是哪一个类就优先调用哪个方法。如果没找到，就向父类寻找
			注意：对象一旦向上转型（父类引用指向子类对象）为父类，那么就无法调用子类原本特有的成员方法
		2、另一种记忆方式（不太好理解）
			成员变量：编译看左边，运行还看左边
			成员方法：编译看左边，运行看右边
	19_使用多态的好处
		1、好处：无论右边的new的时候换成那个子类对象，等号左边调用方法都不会变化
		2、例子：
			1、如果不用多态，只用子类，那么写法是：
				Teacher one = new Teacher();
				one.work();//讲课
				Assistant two = new Assistant();
				two.work();//辅导
				
			我现在唯一要做的事情就是调用work方法。其他的功能不关心
			2、如果使用多态写法，对比一下：
				Employee one = new Teacher();
				one.work();
				Employee two = new Assistant();
				two.work();
	20_对象的向上转型
		1、对象的向上转型，其实就是多态写法：
			格式：父类名称 对象名 = new 子类名称();		Animal animal = new Cat();
			含义：右侧创建一个子类对象，把他看做父类来使用。例如 ：创建了一只猫，当做动物看待，没问题
			注意事项：向上转型一定是安全的的。从小范围转向了大范围，从小范围的猫，向上转向了更大范围的动物（类似于数据类型的自动转换）
		2、向上转型一定是安全的，但是有一个弊端
			对象一旦向上转型为父类，那么就无法调用子类原本特有的内容
			解决方法：用对象的向下转型【还原】（存在条件，对象必须原本是从子类向上转型而来。而且还原后的对象必须是之前子类的对象）
	21_对象的向下转型
		1、对象的向下转型，其实是一个【还原】的动作。
			格式：子类名称 对象名 = (子类名称) 父类对象;
			含义：将父类对象，【还原】成为本来的子类对象
			
			Animal animal = new Cat();//本来是猫，向上转型成为动物
			Cat cat = (Cat) animal;//本来是猫，已经被当做动物了，还原回来成为本来的猫
			
		2、注意事项：
			
			a.必须保证对象本来创建的时候，就是猫，才能向下转型为猫。
			b.如果对象创建的时候不是猫，现在非要转型成为猫，就会抛出异常（编译没有报错，但是运行时会抛出一个java,lang.ClassCastException类转换异常）
			c.在向下转型的时候一定要先进行instanceof进行类型的判断
	22_用instanceof关键字进行类型判断
		1、如何才能知道一个父类引用的对象，本来是什么子类？（一个对象是否为一个类的实例）
			格式：对象 instanceof 类名称
			这将会得到一个boolean值结果，也就是判断前面的对象能不能当做后面类型的实例
	23_笔记本USB接口案例_分析
	24_笔记本USB接口案例_实现
		1、注意事项：在方法的参数中，可能会发生向上转型（方法参数事项多态）
			即形参里面定义的是父类对象，在实参里面可以填写子类对象。因为可以发生向上转型
			
		2、
			//第一种方式手动向上转型
			USB usb = new Mouse();
			computer.useDevice(usb);

			//第二种方式方法参数默认向上转型(使用子类对象)
			Keyboard keyboard = new Keyboard();
			computer.useDevice(keyboard);

			//第三种方式方法参数默认向上转型(使用匿名对象)
			computer.useDevice(new Keyboard());
第5节 final关键字
	01_final关键字概念与四种用法
		1、概念：final关键字代表最终的、不可改变的
		2、常见四种用法：
			1、可以用来修饰一个类
			2、可以用来修饰一个方法
			3、可以用来修饰局部变量
			4、可以用来修饰成员变量
	02_final关键字用于修饰类
		1、当final关键字用来修饰一个类的时候，格式：
			public final class{
				//...
			}
		2、含义：当前这个类不能有任何的子类。（太监类）
		3、注意：一个类是final的，那么其中所有的成员方法都无法进行覆盖重写（因为没子类）
	03_final关键字用于修饰成员方法
		1、当final关键字用来修饰一个方法的时候，这个方法就是最终方法，也就是不能覆盖重写。
			格式：
			修饰符 final 返回值类型 方法名称(参数列表){
				方法体
			}
		2、注意事项：
			对于类、方法来说，abstract关键字和final关键字不能同时使用，因为矛盾。
	04_final关键字用于修饰局部变量
		1、一旦使用final用来修饰局部变量，那么这个变量就不能进行修改了。（"一次赋值，终生不变"）
		2、如果final修饰的局部变量在定义的时候没有进行初始化，那就还可以进行一次赋值，只要保证有唯一一次赋值即可。（因为是局部变量，所以没有默认值）
	***	3、重点注意事项：
			1、对于基本数据类型来说，不可变说的是变量当中的数据不可变。
			2、对于引用类型来说，不可变说的是变量当中的地址值不可改变(即引用类型的数据可以改变，比如对象里面的成员变量)
	05_final关键字用于修饰成员变量
		1、对于成员变量来说，如果使用final来修饰，那么这个变量也照样是不可变的
		2、注意事项：
			1、由于成员变量具有默认值，所以使用了final之后必须手动赋值，不会再给默认值了。
			2、对于final修饰成员变量，要么使用直接赋值，要么通过构造方法赋值。二者选其一
			3、如果使用构造方法赋值，必须保证当中所有的重载的构造方法，都最终会对final的成员变量进行赋值
第6节 权限修饰符
	06_四种权限修饰符
		1、Java中有四种权限修饰符：
										public		>		protected		>		(default)		>		private
			同一个类中(我自己)			yes					yes						yes						yes
			同一个包不同类（我邻居）	yes					yes						yes						no
			不同包的子类（我儿子）		yes					yes						no						no
			不同包非子类（陌生人）		yes					no						no						no
		2、注意事项：
			(default)并不是关键字"default"，而是根本不写
第7节 内部类
	07_内部类的概念与分类
		1、如果一个事物内部包含另一个事物，那么这就是一个类内部包含另一个类
			例如：身体和心脏的关系。又如：汽车和发动机的关系
			
		2、分类：
			1、成员内部类
			2、局部内部类（包含匿名内部类）
	08_成员内部类的定义
		1、定义格式：
			修饰符 class 外部类名称{
				修饰符 class 内部类名称{
					//...
				}
			}
		2、注意事项：
			1、内用外，随意访问，外用内，需要内部类对象
			2、内部类编译生成的class文件名格式是：外部类名$内部类名.class			所以我们命名类名时尽量不要使用$命名，不然容易与内部类冲突
	09_成员内部类的使用
		1、两种使用内部类的方法：
			1、间接方式：
				在外部类的成员方法当中，使用内部类创建内部对象来调用内部类内容，然后在其他的类的main创建外部类对象来调用包含"内部类对象创建"的外部类成员方法。
			2、直接方式：存在公式
				【外部类名称.内部类名称 对象名 = new 外部类名称().new 内部类名称()】
				例如：Body.Heart heart = new Body().new Heart();
	10_内部类的同名变量访问
		1、如果内部类的成员变量出现了重名现象：
			1、内部类调用内部类的局部变量：直接在内部类中调用内部类局部变量
			2、内部类调用内部类的成员变量名：直接在内部类中使用this.内部类成员变量名
			3、内部类调用外部类的成员变量名：外部类名称.this.外部类成员变量名
	11_局部内部类定义
		1、如果一个类是定义在一个方法内部的，那么这就是一个局部内部类
			"局部"：只有当前所属的方法才能使用它，出了这个方法就不能使用了。所以局部内部类必须在方法内创建对象和使用。以及局部内部类的修饰符不用写了（因为不用控制访问范围了）。
		2、定义格式：
			修饰符 class 外部类名称{
				修饰符 返回值类型 外部方法名(参数列表){
					class 局部内部类名称{
						//...
					}
				}
			}
		3、类当中的权限修饰符的使用
			public	>	protected	>	(default)	>	private
			定义一个类的时候，权限修饰符规则：
				1、外部类：public/(default)
				2、成员内部类：public\protected\(default)\private
				3、局部内部类：什么都不能写
	12_局部内部类的final问题
		1、局部内部类，如果希望访问所在方法的局部变量，那么这个局部变量必须是【有效final的】
			备注：从Java8,只要局部变量事实不变，那么final关键字可以省略
		2、原因：简单来说与局部变量的生命周期有关
			1、new出来的对象保存在堆内存当中
			2、局部变量与成员方法一样保存在栈内存当中
			3、方法运行结束之后，立刻出栈，局部变量就会立刻消失
			4、但是局部内部类new出来的对象会在堆内存中持续存在，直到垃圾回收消失
			5、但是局部内部类的对象如果刚好使用所在方法的局部变量的时候。这样就矛盾了。
			所以使用一个常量保存局部变量的数据来给局部内部对象使用。使用final关键字保证这个变量不可变，不然那个常量就失效了
	13_匿名内部类
		1、如果接口的实现类（或者是父类的子类），只需要使用唯一的一次，
			那么这种情况下就可以省略掉该类的定义，而改为使用【匿名内部类】
		2、匿名内部类的定义格式：
			接口名称 对象名 = new 接口名称(){
				//覆盖重写所有抽象方法
			};
			使用：对象名.接口方法名();
			注意：最后的大括号就是匿名内部类
			
	14_匿名内部类的注意事项
		1、对格式"接口名称 对象名 = new 接口名称(){...}"进行解析
			1、对象名是匿名内部类的对象名，省略的是类名不是对象名。
			2、new代表创建对象的动作
			3、接口名称就是匿名内部类需要实现的接口
			4、{...}这才是匿名内部类的内容
		2、匿名内部类的注意事项：
			1、匿名内部类，在【创建对象】时，只能使用唯一一次。
				如果希望多次创建对象，而且类的内容一样的话，那么就必须使用单独定义的实现类了
			2、匿名对象，在【调用方法】的时候，只能调用唯一的一次
				如果希望同一个对象，调用多次方法，那么必须给这个对象起一个名字
			3、匿名内部类是省略了【实现类/子类的名称】，但是匿名对象时省略了【对象名称】
			强调：匿名内部类和匿名对象不是一回事！！！
	15_类作为成员变量类型
		1、成员变量的类型不止基本数据类型还有引用数据类型，可以使用自定义类作为数据类型
		2、String也是一个类，只是这个类是jdk这个作者写的
	16_接口作为成员变量类型
		1、使用实现类来实现接口，创建实现类对象给成员变量赋值
		2、使用匿名内部类来实现接口，匿名内部类对象给成员变量赋值
		3、使用匿名内部类和匿名对象来实现接口，直接赋值给成员变量
	17_接口作为方法的参数和或返回值
		java.util.List正是ArrayList所实现的接口
	18_发红包案例_分析
		1、场景说明：
			红包发出去之后，所有人都有红包，大家抢完之后，最后一个红包给群主自己
			大多数代码都是现成的，我们需要做的是填空题。
			我们自己要做的事情有：
				1、设置一下程序的标题，通过构造方法的字符串参数
				2、设置群主名称
				3、设置分发策略：平均？还是手气？
		2、红包分发策略：
			1、普通红包（平均）：totalMoney / totalCount 余数放在最后一个红包当中
			2、手气红包（随机）：最少1分钱，最多不超过平均数的2倍。应该越发越少
	19_发红包案例_普通红包平均分发
	20_发红包案例_手气红包随机分发
	
		手气抢红包算法：
        1、二倍均值法（微信红包策略）：公式：【1+random.nextInt((leftMoney/leftCount)*2)】
            剩余红包金额M，剩余人数N，那么：每次抢到金额=随机(0，M/N*2)
            保证了每次随机金额的平均值是公平的
            假设10人，红包金额100元
            第一人：100/10*2=20，随机范围(0,20)，平均可以抢到10元
            第二人：90/9*2=20，随机范围(0,20)，平均可以抢到10元
            第三人：80/8*2=20，随机范围(0,20)，平均可以抢到10元
			
			3		1000分
			1000/3*2=666		(1,666)		333
			666/2*2=666			(1,666)		333
											333
            以此类推，每次随机范围的均值是相等的

            (M-(M/N))/(N-1) = ((MN-M)/N)/(N-1) = (M(N-1)/N)/(N-1) = M/N
            缺点：除了最后一次，任何一次抢到的金额都不会超过人均金额的两倍，并不是任意的随机。
        2、线段切割法
            相当于把总金额都变成1分分的钞票，随机使用木板插入里面，保证木板不重叠以及里面至少有1分钱即可。
            优点：公平
            缺点：发个数少的话，真.随机，差距大。